---
title: "ThunderBio VDJ Report"
date: "`r Sys.Date()`"
output: 
  flexdashboard::flex_dashboard:
    vertical_layout: scroll
    orientation: rows
    theme: 
      bootswatch: flatly
      version: 5
params:
  sampleName : "sampleName"
  qualimap_out : "rnaseq_qc_results.txt"
  qualimap_gene_coverage : "qualimap_gene_coverage.txt"
  starsolo_matrixDir: "sample/Gene/filtered"
  starsolo_out : "Summary.csv"
  starsolo_bc : "UMIperCellSorted.txt"
  saturation_json: "saturation_out.json"
  version_json: "versions.json"
  nCPUs: 10
  nMem: 10000000000.0
  nFeature_RNA_lower: 200
  percent_mt_cutoff: 100
  pca_dim: 30
  resolution: 0.8
  VDJ_B_report: "VDJ_B_report.tsv"
  VDJ_B_airr: "VDJ_B_airr.tsv"
  VDJ_B_kneeOut: "VDJ_B_kneeOut.tsv"
  VDJ_B_finalOut: "VDJ_B_finalOut.tsv"
  VDJ_B_cells: "VDJ_B_cells.tsv"
  VDJ_B_metrics: "VDJ-B_metrics.json"
  VDJ_B_cloneType : "VDJ-B.cloneType.tsv"
  VDJ_T_report: "VDJ_T_report.tsv"
  VDJ_T_airr: "VDJ_T_airr.tsv"
  VDJ_T_kneeOut: "VDJ_T_kneeOut.tsv"
  VDJ_T_finalOut: "VDJ_T_finalOut.tsv"
  VDJ_T_cells: "VDJ_T_cells.tsv"
  VDJ_T_metrics: "VDJ-T_metrics.json"
  VDJ_T_cloneType: "VDJ-T.cloneType.tsv"
  withUMI: TRUE
---

```{css echo = FALSE}
.chart-title {
  font-size: 1.2rem;
  font-weight: 700;
  margin-left: 10px;
  margin-right: 10px;
}
```

```{js echo = FALSE}
// shrink navbar height
document.querySelector(".navbar").classList.add("pt-1")
document.querySelector(".navbar").classList.add("pb-1")
```

```{r include=FALSE}
library(tidyverse)
library(scales)
library(flexdashboard)
library(jsonlite)
library(DT)
##library(htmlwidgets)
library(plotly)
library(kableExtra)
library(Seurat)
library(future)
library(SeuratDisk)
##library(VennDiagram)
library(Biostrings)
library(data.table)
library(matrixStats)
library(reshape2)
library(ComplexHeatmap)
library(seqinr)
library(stringi)
library(patchwork)
library(htmltools)

set.seed(1234)
plan(multisession, workers = as.numeric(params$nCPUs))
options(future.globals.maxSize = as.numeric(params$nMem), sass.cache = FALSE)
RhpcBLASctl::blas_set_num_threads(1) # https://github.com/satijalab/seurat/issues/3991

## Rmd options
knitr::opts_chunk$set(
  comment = '', fig.retina = 4,
  warning = FALSE, message = FALSE
)


config_plotly_fig <- function(fig, ...){
    config(
        fig,
        displaylogo = FALSE, 
        modeBarButtonsToRemove = c('zoom', 'pan', 'select', 'zoomIn', 'zoomOut', 'autoScale',
                                   'hoverClosestCartesian', 'hoverCompareCartesian'),
        toImageButtonOptions = list(height= NULL, width= NULL, scale= 2),
        ...
    )
}


## decide whether to incldue each page
## conditional page solution is from: https://stackoverflow.com/questions/59202693/how-can-i-create-a-conditional-flexdashboard-layout
if(is.null(params$starsolo_matrixDir) || params$starsolo_matrixDir == "") {
    include_gex <- FALSE
}else{
    include_gex <- TRUE
}
if(is.null(params$VDJ_T_metrics) || params$VDJ_T_metrics == "") {
    include_tcr <- FALSE
}else{
    include_tcr <- TRUE
}
if(is.null(params$VDJ_B_metrics) || params$VDJ_B_metrics == "") {
    include_bcr <- FALSE
}else{
    include_bcr <- TRUE
}


## Note since GEX data only support UMI, so include_gex requires withUMI == TRUE
if(include_gex && !params$withUMI){
    stop("GEX data requires library structure containing UMI")
}
```


```{r infoIcon, include = FALSE}
infoIcon <- function(targetEl, size = "1.2rem"){
  querySelector <- paste0("#", targetEl)
  ## Make HTML
  outTag <- tags$i(
      bsicons::bs_icon("question-circle-fill",
              size = size,
              fill = "var(--bs-primary)"),
      `data-bs-toggle`="modal",
      `data-bs-target`=querySelector
  )
  return(outTag)
}

createModal <- function(Id, expl_tbl){
    contentTag <- expl_tbl %>%
        apply(1, FUN=function(x){
            tagList(
                h6(HTML(x[1]), style="font-weight:700;"),
                p(HTML(x[2]))
            )
        }) %>% 
        tagList()

   outTag <- div(
       class = "modal fade",
       id = Id,
       tabindex = -1,
       `aria-labelledby`="exampleModalLabel",
       `aria-hidden`="true",
       div(
           class = "modal-dialog modal-dialog-centered modal-dialog-scrollable modal-lg",
           div(
               class = "modal-content",
               div(
                   class = "modal-body",
                   div(
                       class = "explanation",
                       contentTag
                   )
               )
           )
       )
   )
   return(outTag)
}
```

```{css}
.explanation {
  background-color: rgba(var(--bs-secondary-rgb), 0.2); 
  border-radius: var(--bs-modal-border-radius);
  padding: 1rem
}
```


```{r include = FALSE}
## Combine TCR/BCR information from barcode_report and airr_report
combineInfo <- function(cells, barcode_report, airr_report){
    d <- read_tsv(barcode_report) %>%
        dplyr::rename("barcode" = "#barcode") %>%
        select(barcode, chain1, chain2, secondary_chain1, secondary_chain2) %>% 
        filter(barcode %in% cells)
    
    d$chain1_contig <- strsplit(d$chain1,",") %>% sapply("[", 8)
    d$chain2_contig <- strsplit(d$chain2,",") %>% sapply("[", 8)
    
    d$chain1_V <- strsplit(d$chain1,",") %>% sapply("[",1) %>% str_remove("\\*[0-9]+$")
    d$chain1_D <- strsplit(d$chain1,",") %>% sapply("[",2) %>% str_remove("\\*[0-9]+$")
    d$chain1_J <- strsplit(d$chain1,",") %>% sapply("[",3) %>% str_remove("\\*[0-9]+$")
    d$chain1_cdr3 <- strsplit(d$chain1,",") %>% sapply("[",5)
    
    d$chain2_V <- strsplit(d$chain2,",") %>% sapply("[",1) %>% str_remove("\\*[0-9]+$")
    d$chain2_D <- strsplit(d$chain2,",") %>% sapply("[",2) %>% str_remove("\\*[0-9]+$")
    d$chain2_J <- strsplit(d$chain2,",") %>% sapply("[",3) %>% str_remove("\\*[0-9]+$")
    d$chain2_cdr3 <- strsplit(d$chain2,",") %>% sapply("[",5)
    
    airr <- read_tsv(airr_report) %>%
        select(sequence_id, sequence, cdr1, cdr2, complete_vdj, productive)
    
    d <- d %>% 
        left_join(airr, by = c("chain1_contig" = "sequence_id")) %>%
        dplyr::rename(
            "chain1_contigSeq" = "sequence",
            "chain1_cdr1" = "cdr1",
            "chain1_cdr2" = "cdr2",
            "chain1_complete" = "complete_vdj",
            "chain1_productive" = "productive"
        ) %>%
        left_join(airr, by = c("chain2_contig" = "sequence_id")) %>%
        dplyr::rename(
            "chain2_contigSeq" = "sequence",
            "chain2_cdr1" = "cdr1",
            "chain2_cdr2" = "cdr2",
            "chain2_complete" = "complete_vdj",
            "chain2_productive" = "productive"
        )
    d$chain1_cdr3aa <- strsplit(d$chain1, ",") %>% sapply("[", 6)
    d$chain2_cdr3aa <- strsplit(d$chain2, ",") %>% sapply("[", 6)
    d$chain1_expr <- strsplit(d$chain1, ",") %>% sapply("[", 7) %>% as.numeric()
    d$chain2_expr <- strsplit(d$chain2, ",") %>% sapply("[", 7) %>% as.numeric()
    d <- d %>%
        mutate(
            chain1_type = case_when(
                str_detect(chain1_V, "IGH") ~ "IGH",
                str_detect(chain1_D, "IGH") ~ "IGH",
                str_detect(chain1_J, "IGH") ~ "IGH",
                str_detect(chain1_V, "TRB") ~ "TRB",
                str_detect(chain1_D, "TRB") ~ "TRB",
                str_detect(chain1_J, "TRB") ~ "TRB",
                str_detect(chain1_V, "TRD") ~ "TRD",
                str_detect(chain1_D, "TRD") ~ "TRD",
                str_detect(chain1_J, "TRD") ~ "TRD",
                TRUE ~ "unknown"
            ),
            chain2_type = case_when(
                str_detect(chain2_V, "IGK") ~ "IGK",
                str_detect(chain2_J, "IGK") ~ "IGK",
                str_detect(chain2_V, "IGL") ~ "IGL",
                str_detect(chain2_J, "IGL") ~ "IGL",
                str_detect(chain2_V, "TRA") ~ "TRA",
                str_detect(chain2_J, "TRA") ~ "TRA",
                str_detect(chain2_V, "TRG") ~ "TRG",
                str_detect(chain2_J, "TRG") ~ "TRG",
                TRUE ~ "unknown"
            )
        )
    d <- d %>% dplyr::select(-c(chain1, chain2))
    ## relocate columns
    d <- d %>% 
        dplyr::select(barcode, 
                      chain1_V, chain1_D, chain1_J, chain1_cdr1, chain1_cdr2, chain1_cdr3, chain1_cdr3aa, 
                      chain1_complete, chain1_productive, chain1_type, chain1_expr, chain1_contig, chain1_contigSeq, secondary_chain1,
                      chain2_V, chain2_D, chain2_J, chain2_cdr1, chain2_cdr2, chain2_cdr3, chain2_cdr3aa, 
                      chain2_complete, chain2_productive, chain2_type, chain2_expr, chain2_contig, chain2_contigSeq, secondary_chain2) %>%
        mutate(across(c(starts_with("chain"), starts_with("secondary")), 
                      .fns = function(x) ifelse(x != "*", x, NA)))
    return(d)
}
## Lineage stats
## Get lineage information, only using cells with paired and productive chains
## Lineage defined as the same VDJ segments, identical CDR3 nucleotides length and > 80% CDR3 nt
getLineage <- function(cells, barcode_report, airr_report){
    
    d <- combineInfo(cells, barcode_report, airr_report)
    
    ## filter d to only retain the cells with the productive chains
    d0 <- d %>%
        filter(!is.na(chain1_contig), !is.na(chain2_contig)) %>%
        filter(chain1_productive == TRUE, chain2_productive == TRUE) %>%
        mutate(cdrh3_len = str_length(chain1_cdr3)) %>%
        group_by(chain1_V, chain1_D, chain1_J, chain2_V, chain2_D, chain2_J, cdrh3_len) %>% 
        group_split()
    
    d_single <- d0[sapply(d0, nrow)==1]
    d_multiple <- d0[sapply(d0, nrow)>1]
    
    d_multiple_final <- list()
    if(length(d_multiple)>0){
        for(i in 1:length(d_multiple)){
            
            k <- d_multiple[[i]] %>% pull(chain1_cdr3)
            aln <- as.alignment(nb = length(k), nam = 1:length(k), k)
            aln_dist <- dist.alignment(aln, matrix = "identity",gap = T) %>% as.matrix()
            identityM <- 1-aln_dist^2
            
            tr <- hclust(as.dist(1-identityM))
            ## use cutree to define families, cutoff is 0.2 (80% identity)
            familyIdx <- cutree(tr, h=0.2)
            
            if(length(unique(familyIdx))==1){
                d_multiple_final[[length(d_multiple_final)+1]] <- d_multiple[[i]]
            }else{
                m <- d_multiple[[i]] %>%
                    mutate(family=as.character(familyIdx)) %>%
                    ungroup() %>%
                    group_by(family) %>%
                    group_split(.keep = FALSE)
                for(u in 1:length(m)){
                    if(nrow(m[[u]])>1){
                        d_multiple_final[[length(d_multiple_final)+1]] <- m[[u]]
                    }else{
                        d_single[[length(d_single)+1]] <- m[[u]]
                    }
                }
            }
        }
    }
    
    singleInfo <- list()
    if(length(d_single)>0){
        for(i in 1:length(d_single)){
            singleInfo[[i]] <- d_single[[i]] %>%
                mutate(lineageType = "single",
                       lineageName = paste0("LS", i))
        }
    }
    multipleInfo <- list()
    if(length(d_multiple_final)>0){
        for(i in 1:length(d_multiple_final)){
            multipleInfo[[i]] <- d_multiple_final[[i]] %>%
                mutate(lineageType = "multiple",
                       lineageName = paste0("LM", i))
        }
    }
    single_df <- do.call(bind_rows, singleInfo)
    multiple_df <- do.call(bind_rows, multipleInfo)
    lineageInfo <- bind_rows(single_df, multiple_df)
    return(ungroup(lineageInfo))
}
```


```{r include = FALSE}
## pairing accuracy
## Defined as cells with identical H chain VDJ as well as CHRH3 but different L chain VDJ
## take lineageInfo data (getLineage() output) as input

calc_pairing_accuracy <- function(lineageInfo){
    totalCells <- nrow(lineageInfo)
    d <- lineageInfo %>% ungroup() %>%
        group_by(chain1_V, chain1_D, chain1_J, chain1_cdr3) %>%
        group_split()
    disconcordantCells <- d %>% sapply(FUN = function(x){
        x %>% select(chain2_V, chain2_J) %>%
            ungroup() %>%
            group_by(chain2_V, chain2_J) %>%
            summarize(count = n()) %>% 
            arrange(desc(count)) %>%
            slice_tail(n=-1) %>%
            pull(count) %>%
            sum()
    }) %>%
    sum()
    return(1-disconcordantCells/totalCells)
}
```


```{r include = FALSE}
## https://liulab-dfci.github.io/RIMA/Repertoire.html#tcr-and-bcr-entropy-and-clonality
## function to calculate Shannon entropy and clonality
## take lineageInfo data (getLineage() output) as input

getEntropy <- function(lineageInfo){
    totalCells <- nrow(lineageInfo)
    ## use cloneType instead of family
    d <- lineageInfo %>% 
        ungroup() %>%
        group_by(chain1_V, chain1_D, chain1_J, chain1_cdr3, chain2_V, chain2_J, chain2_cdr3) %>%
        summarize(cellCount = n()) %>%
        mutate(percent = cellCount/totalCells) %>%
        pull(percent)
    entropy <- -sum(log(d)*d)
}

getClonality <- function(entropy, cloneTypeNum){
    1-(entropy/log(cloneTypeNum))
}
```


```{r include = FALSE}
## VDJ coverage function
## contributed by Yuanzhen (yuanzhen@thunder-bio.com)
plot_VDJ_coverage <- function(cells, barcode_report, airr_report, trust4_final_out, type = "VDJ-B"){
  
  cell_report <- read_delim(barcode_report,
                            delim = "\t", escape_double = FALSE,
                            trim_ws = TRUE) %>% 
    dplyr::rename(barcode=`#barcode`) %>%
    filter(barcode %in% cells)
  d <- cell_report %>% select(barcode, chain1, chain2)
  d$chain1_contig <- strsplit(d$chain1,",") %>% sapply("[", 8)
  d$chain2_contig <- strsplit(d$chain2,",") %>% sapply("[", 8)
  airr <- read_delim(airr_report, 
                     delim = "\t", escape_double = FALSE,
                     trim_ws = TRUE)
  
  VDJ_final_matrix=fread(trust4_final_out,
                         sep="",
                         header = F)
  
  name_fi_=VDJ_final_matrix$V1 %>% str_remove_all(">") %>% str_remove_all("\\s[A-Z]+.*")
  
  chain1_info <- airr %>% select(sequence_id, sequence, junction, cdr1, cdr2) %>% 
    filter(sequence_id %in% na.omit(d$chain1_contig)) %>% filter(str_length(junction)>4)
  chain2_info <- airr %>% select(sequence_id, sequence, junction, cdr1, cdr2) %>% 
    filter(sequence_id %in% na.omit(d$chain2_contig)) %>% filter(str_length(junction)>4)
  
  if(type == "VDJ-B"){
    p1 <- .vh_vl_plot(vdj_type = "BCR_VH", chainInfo = chain1_info, name_fi = name_fi_)
    p2 <- .vh_vl_plot(vdj_type = "BCR_VL", chainInfo = chain2_info, name_fi = name_fi_)
  }else if(type == "VDJ-T"){
    p1 <- .vh_vl_plot(vdj_type = "TCR_VH", chainInfo = chain1_info, name_fi = name_fi_)
    p2 <- .vh_vl_plot(vdj_type = "TCR_VL", chainInfo = chain2_info, name_fi = name_fi_)
  }
  
  plotList <- list(chain1_plot = p1, chain2_plot = p2)
  
  return(plotList)
}


extract_cdr_start <- function(vdj_seq, cdr_seq){
    stri_locate_last(vdj_seq, regex = cdr_seq)[1]
}

extract_cdr_end <- function(vdj_seq, cdr_seq){
    stri_locate_last(vdj_seq, regex = cdr_seq)[2]
}

.vh_vl_plot=function(vdj_type, chainInfo, name_fi){
  
  chainInfo=chainInfo[!is.na(chainInfo$junction), ]
  ## Remove cells with too short cdr3 (4nt)
  chainInfo <- chainInfo %>%
      filter(str_length(junction)>4)
  
  if(nrow(chainInfo)==0){
    stop("your VDJ do not complete(not have cdr3 at least)")
  }
  
  ## generate cdr start and end
  chainInfo$cdr1_start <- map2_int(chainInfo$sequence, chainInfo$cdr1, .f = extract_cdr_start)
  chainInfo$cdr1_end <- map2_int(chainInfo$sequence, chainInfo$cdr1, .f = extract_cdr_end)
  chainInfo$cdr2_start <- map2_int(chainInfo$sequence, chainInfo$cdr2, .f = extract_cdr_start)
  chainInfo$cdr2_end <- map2_int(chainInfo$sequence, chainInfo$cdr2, .f = extract_cdr_end)
  chainInfo$cdr3_start <- map2_int(chainInfo$sequence, chainInfo$junction, .f = extract_cdr_start)
  chainInfo$cdr3_end <- map2_int(chainInfo$sequence, chainInfo$junction, .f = extract_cdr_end)
  
  chain_locate=match(chainInfo$sequence_id, name_fi)
  
  
  #B cell  IMGT numbering
  #
  #IGHV
  #cdr1:27-38
  #cdr2:56-65
  #cdr3:105-115
  #
  #IGKV
  #cdr1:27-38
  #cdr2:56-65
  #cdr3:105-1100
  #
  #
  #IGLV
  #cdr1:27-38
  #cdr2:56-65
  #cdr3:105-115
  #
  #
  # more information about B cell numberiing https://www.imgt.org/IMGTScientificChart/Numbering/IMGT-Kabat_part1.html
  #
  #T cell IMGT numbering
  #
  #TRBV
  #cdr1:27-38
  #cdr2:56-65
  #cdr3:105-109
  #
  #
  #TRAV
  #cdr1:27-38
  #cdr2:56-65
  #cdr3:105-107
  #
  #TRDV
  #cdr1:27-38
  #cdr2:56-65
  #cdr3:105-108
  #
  #
  #TRGV
  #cdr1:27-38
  #cdr2:56-65
  #cdr3:105-109
  #
  #
  #more information about T cell numberiing:https://www.imgt.org/IMGTScientificChart/Numbering/IMGT-Kabat_part2.html
  #
  if(vdj_type=="BCR_VH"){
    cdr1_start=27
    cdr1_end=38
    cdr2_start=56
    cdr2_end=65
    cdr3_start=105
    cdr3_end=115
  }else if(vdj_type=="BCR_VL"){
    cdr1_start=27
    cdr1_end=38
    cdr2_start=56
    cdr2_end=65
    cdr3_start=105
    cdr3_end=115
  }else if(vdj_type=="TCR_VH"){
    ## used TRB location as representative
    cdr1_start=27
    cdr1_end=38
    cdr2_start=56
    cdr2_end=65
    cdr3_start=105
    cdr3_end=109
  }else if(vdj_type=="TCR_VL"){
    ## used TRA location as representative
    cdr1_start=27
    cdr1_end=38
    cdr2_start=56
    cdr2_end=65
    cdr3_start=105
    cdr3_end=109
  }else{
    errorCondition("your vdj_type not correctly, please use VH or VL")
  }
  
  ## Align sequences
  convert_position <- function(imgt_cdr3_aa_start, cdr3_start, seq_position){
      return(seq_position + as.integer(imgt_cdr3_aa_start) * 3L - cdr3_start)
  }
  
  ## Do not use pmap_int() here!
  ## Note 3L above
  chainInfo$cdr1_start_aligned <- pmap_dbl(list(cdr3_start, chainInfo$cdr3_start, chainInfo$cdr1_start), .f = convert_position)
  chainInfo$cdr1_end_aligned <- pmap_dbl(list(cdr3_start, chainInfo$cdr3_start, chainInfo$cdr1_end), .f = convert_position)
  chainInfo$cdr2_start_aligned <- pmap_dbl(list(cdr3_start, chainInfo$cdr3_start, chainInfo$cdr2_start), .f = convert_position)
  chainInfo$cdr2_end_aligned <- pmap_dbl(list(cdr3_start, chainInfo$cdr3_start, chainInfo$cdr2_end), .f = convert_position)
  chainInfo$cdr3_start_aligned <- pmap_dbl(list(cdr3_start, chainInfo$cdr3_start, chainInfo$cdr3_start), .f = convert_position)
  chainInfo$cdr3_end_aligned <- pmap_dbl(list(cdr3_start, chainInfo$cdr3_start, chainInfo$cdr3_end), .f = convert_position)
  chainInfo$seq_start_aligned <- pmap_dbl(list(cdr3_start, chainInfo$cdr3_start, rep(1, nrow(chainInfo))), .f = convert_position)
  chainInfo$seq_end_aligned <- pmap_dbl(list(cdr3_start, chainInfo$cdr3_start, str_length(chainInfo$sequence)), .f = convert_position)

  chain_count <- lapply(1:length(chain_locate), function(i){
    nt_1_weight <- name_fi[chain_locate[i]+2] %>% str_split(" ") %>% unlist() %>% as.numeric()
    nt_2_weight <- name_fi[chain_locate[i]+3] %>% str_split(" ") %>% unlist() %>% as.numeric()
    nt_3_weight <- name_fi[chain_locate[i]+4] %>% str_split(" ") %>% unlist() %>% as.numeric()
    nt_4_weight <- name_fi[chain_locate[i]+5] %>% str_split(" ") %>% unlist() %>% as.numeric()
    nt_weight_matrix <- matrix(
        c(nt_1_weight, nt_2_weight,
          nt_3_weight, nt_4_weight),
        nrow=4,
        byrow = T
    )
    nt_depth <- nt_weight_matrix %>% colMaxs(na.rm = T)
    seq_len <- str_length(nt_depth)
    ## Add NA to depth if the sequence is not complete VDJ
    if(chainInfo$seq_start_aligned[i] > 0){
        ## Add NA if the sequence is not from 0
        nt_depth <- c(rep(NA,  chainInfo$seq_start_aligned[i] - 1), nt_depth)
    }else{
        ## or trim first several nt with minus position
        nt_depth <- nt_depth[(1-chainInfo$seq_start_aligned[i]):length(nt_depth)]
    }
    ## set max length to 120*3
    if(120*3 - chainInfo$seq_end_aligned[i] > 0){
        nt_depth <- c(nt_depth, rep(NA, 120*3 - chainInfo$seq_end_aligned[i]))
    }else{
        nt_depth <- nt_depth[1:(120*3)]
    }
  })
  
  chain_dt=do.call(rbind,chain_count)
  chain_dt[is.na(chain_dt)] <- 0

  ## convert nt data to aa
  chain_aa_dt <- matrix(data = NA, nrow = nrow(chainInfo), ncol = 120, byrow = TRUE)
  for(m in 1:nrow(chain_dt)){
      for(n in 1:120){
          chain_aa_dt[m, n] <- mean(chain_dt[m, (n-1)*3+1], chain_dt[m, (n-1)*3+2], chain_dt[m,(n-1)*3+3], )
      }
  }
  dt_final <- data.frame(
      length_aa= 1:120,
      median_reads= colMedians(chain_aa_dt, na.rm = T),
      up=colQuantiles(chain_aa_dt, probs = 0.75, na.rm = T),
      down=colQuantiles(chain_aa_dt, probs = 0.25, na.rm = T)
  )
  ## prepare position data for cdr rect
  cdr1_min_start <- min(chainInfo$cdr1_start_aligned)/3
  cdr1_max_end <- max(chainInfo$cdr1_end_aligned)/3
  if(is.na(cdr1_min_start) || is.na(cdr1_max_end)){
      cdr1_min_start <- cdr1_start
      cdr1_max_end <- cdr1_end
  }

  cdr2_min_start <- min(chainInfo$cdr2_start_aligned)/3
  cdr2_max_end <- max(chainInfo$cdr2_end_aligned)/3
  if(is.na(cdr2_min_start) || is.na(cdr2_max_end)){
      cdr2_min_start <- cdr2_start
      cdr2_max_end <- cdr2_end
  }
  
  cdr3_min_start <- min(chainInfo$cdr3_start_aligned)/3
  cdr3_max_end <- max(chainInfo$cdr3_end_aligned)/3
  if(is.na(cdr3_min_start) || is.na(cdr3_max_end)){
      cdr3_min_start <- cdr3_start
      cdr3_max_end <- cdr3_end
  }
  if(cdr3_max_end > 125){
      cdr3_max_end <- cdr3_end
  }
  
  p <- ggplot(data = dt_final, 
              mapping = aes(x=length_aa, y = median_reads)) + 
    geom_rect(aes(xmin = cdr1_min_start, xmax = cdr1_max_end, ymin=-Inf,ymax=Inf),
              fill="lightgreen",alpha=0.3)+
    annotate(geom = "text",x=ceiling((cdr1_min_start+cdr1_max_end)/2),y = Inf,
             label="CDR1", vjust=1.5)+
    geom_rect(aes(xmin=cdr2_min_start,xmax=cdr2_max_end,ymin=-Inf,ymax=Inf),
              fill="lightgreen",alpha=0.3)+
    annotate(geom = "text",x=ceiling((cdr2_min_start+cdr2_max_end)/2),y= Inf,
             label="CDR2", vjust=1.5)+
    geom_rect(aes(xmin=cdr3_min_start,xmax=cdr3_max_end,ymin=-Inf,ymax=Inf),
              fill="lightgreen",alpha=0.3)+
    annotate(geom = "text",x=ceiling((cdr3_min_start+cdr3_max_end)/2),y = Inf,
             label="CDR3", vjust=1.5)+
    geom_line(linetype=1)+
    geom_line(mapping = aes(x=length_aa, y=up),linetype=2)+
    geom_line(mapping = aes(x=length_aa, y=down),linetype=2)+
    xlab("VDJ residual (IMGT scheme)")+ylab("UMI/Read Coverage")+
    theme_classic()
  
  if(vdj_type == "BCR_VH"){
    p <- p + ggtitle("IGH")
  }else if(vdj_type == "BCR_VL"){
    p <- p + ggtitle("IGK/L")
  }else if(vdj_type == "TCR_VH"){
    p <- p + ggtitle("TRB/D")
  }else if(vdj_type == "TCR_VL"){
    p <- p + ggtitle("TRA/G")
  }
  return(p)
}
```

```{r include = FALSE}
#A function to analysis VDJ lineages and visualization
# 
# author: yuanzhen (yuanzhen@thunder-bio.com)
#
# parameters:
#
#barcode_report: characters,file path,barcode report from trust4
#airr_report: characters,file path,airr report from trust4
#
#output
#
#a heatmap png of Variable germline gene segment pairing for B-cell repertoires
#a barplot png indicate the number of cells for the top 50 lineages
#a pie plot png indicate the number of cells for the top 50 lineages
#a csv file include the analysis information
#
#
plot_lineages=function(barcode_report_file, airr_report_file){
  
  barcode_report <- read_delim(barcode_report_file,
                               delim = "\t", escape_double = FALSE, 
                               trim_ws = TRUE,show_col_types = F)
  
  suppressWarnings(
      airr <- read_delim(airr_report_file, 
                         delim = "\t", escape_double = FALSE, 
                         trim_ws = TRUE,show_col_types = F)
  )
  

  
  save_csv=.make_clone_type(airr_fe = airr, barcode_fe = barcode_report)
  
  write_csv(save_csv,"barcode_clonetype.csv",quote = "none")
  
  ig_info_all= save_csv%>%
    distinct(.keep_all = TRUE) %>%
    group_by(ig) %>% 
    summarize(type_number = n()) %>%
    mutate(IGH=str_split(ig,"_") %>% sapply("[",1) %>% str_remove("[*][0-9]+"),
           IGL=str_split(ig,"_") %>% sapply("[",4) %>% str_remove("[*][0-9]+"))%>% 
    select(IGH,IGL,type_number) %>%
    filter(IGH!="*") %>%
    filter(IGL!="*") %>% arrange(desc(type_number))
  
  ig_info=ig_info_all%>% 
    dcast(IGH ~ IGL,value.var="type_number") %>%
    column_to_rownames(var = "IGH")
  
  ig_info=ig_info/nrow(ig_info_all)
  #######  heatmap plot ########

  dt_=data.frame(vh=ig_info%>% sapply("[",1) %>% str_remove("r"),
                 vl=ig_info%>% sapply("[",3)%>% str_remove("r")) %>% 
    mutate(ig=str_c(vh,vl)) %>% 
    group_by(ig) %>% 
    mutate(count=n())%>% 
    ungroup() %>% 
    distinct() %>% 
    select(vh,vl,count)
  
  dt_1=dt_ %>%
    pivot_wider(id_cols = vh,names_from = vl,values_from = count) %>%
    column_to_rownames("vh")
  
  dt_1= dt_1/nrow(dt_)
  dt_1[is.na(dt_1)]=0
  
  lineages_count=dt_1 %>% as.matrix()
  lineages_count=lineages_count[,colnames(lineages_count) %>% sort()]
  lineages_count=lineages_count[rownames(lineages_count) %>% sort(),]
  column_ha <- HeatmapAnnotation(
    L = anno_barplot(colSums(lineages_count),border = F),
    show_annotation_name  = F
  )
  row_ha <- rowAnnotation(
    H = anno_barplot(rowSums(lineages_count),
                     axis_param = list(direction = "reverse"),border = F),
    show_annotation_name=F)
  #lineages_count[lineages_count > 0.01]=0.01
  ph <- Heatmap(lineages_count,
            cluster_columns = F,
            cluster_rows = F,
            top_annotation = column_ha, 
            left_annotation = row_ha,
            col = RColorBrewer::brewer.pal(9,"OrRd"),
            column_names_gp = gpar(fontsize = 6),
            row_names_gp = gpar(fontsize = 4),
            heatmap_legend_param = list(title="",at=c(0,max(lineages_count)),labels=c("0",">1%"))
  )
  
  #######  barplot ########
  bar_plot=data.frame(rank=1:50,
                      number_type=ig_info_all$type_number[1:50])
  
  p2=ggplot(bar_plot, aes(x=rank,y=number_type)) + 
    geom_bar(color = 'black', fill='lightblue',stat="identity")+
    xlab("Top 50 lineages")+ylab("No. of cells per lineages")+
    theme_classic()
  
  ######## pie plot ####
  
  info = c(ig_info_all %>% filter(type_number > 1) %>% nrow(), 
           ig_info_all %>% filter(type_number == 1) %>% nrow())
  piepercent = c(paste0(round(info[1]/sum(info),4)*100,"%"), 
                 paste0(round(info[2]/sum(info),4)*100,"%"))
  names = c("Cell in expanded lineages", 
            "Cell in singleton lineages")
  
  cols = c("#3f48CC","grey")
  pie(info,labels=piepercent,col=cols)
  legend("topright", names, cex=1, fill=cols,border = "white")
}

.make_clone_type=function(airr_fe, barcode_fe){

  #airr_fe=airr_fe[!str_detect(airr_fe$sequence_id,"-"),]
  #airr_fe=airr_fe[airr_fe$productive,]
  #airr_fe=airr_fe[airr_fe$complete_vdj,]
  airr_fe$junction_length=str_length(airr_fe$junction)
  barcode_fe =filter(barcode_fe ,`#barcode` %in% airr_fe$sequence_id)
  barcode_fe=barcode_fe[!barcode_fe$chain1=="*",]
  barcode_fe=barcode_fe[!barcode_fe$chain2=="*",]
  barcode_fe$sequence_id=barcode_fe$`#barcode`
  ig_info_all_unf=data.frame(cell_id=barcode_fe$`#barcode`,
                             igh=paste0(barcode_fe$chain1 %>% str_split(",") %>% sapply("[",1),
                                        "_",
                                        barcode_fe$chain1 %>% str_split(",") %>% sapply("[",2),
                                        "_",
                                        barcode_fe$chain1 %>% str_split(",") %>% sapply("[",3)),
                             igk=paste0(barcode_fe$chain2 %>% str_split(",") %>% sapply("[",1),
                                        "_",
                                        barcode_fe$chain2 %>% str_split(",") %>% sapply("[",2),
                                        "_",
                                        barcode_fe$chain2 %>% str_split(",") %>% sapply("[",3)),
                             igh_cdr3=barcode_fe$chain1 %>% str_split(",") %>% sapply("[",6),
                             umi_length_vh=barcode_fe$chain1 %>% str_split(",") %>% sapply("[",7),
                             umi_length_vl=barcode_fe$chain2 %>% str_split(",") %>% sapply("[",7))%>%
    mutate(ig=paste0(igh,"_",igk) ) %>%
    distinct(.keep_all = TRUE) 
  
  
  ig_info_split=split(ig_info_all_unf,ig_info_all_unf$ig)
  
    ig_info_f=lapply(1:length(ig_info_split),function(i){
    xz=ig_info_split[[i]]
    if(nrow(xz)>1){
      m=xz$igh_cdr3
      yz=as.alignment(nb=length(m),nam = 1:length(m),m)
      zt=dist.alignment(yz, matrix = "identity",gap = T) %>% as.matrix()
      t=1-zt^2
      thre=1+(length(m)-1)*0.8
      if(!any(colSums(t)<thre)){
        xz
      }else{
        xz[-which(colSums(t)<thre),]
      }
    }else{
      return(xz)
    }
  })
  
  
  
  ig_info_save=lapply(1:length(ig_info_f),function(x){
    mutate(ig_info_f[[x]],clonetype=x)
  })
  ig_info_save=ig_info_save[-which(lapply(ig_info_save,nrow) %>% unlist ==0)]
  a_tt=do.call(rbind,ig_info_save)
  left_join(a_tt,airr_fe,by=join_by("cell_id"=="sequence_id"))
}
```


```{r modal, echo = FALSE}
expl_tbl <- tribble(
    ~title, ~content,
    "GEX Association",
    "Detected BCR CDR3 clones were projected to cells' UMAP-plot, only paired productive clones were shown. Please note both of the productive and unproductive BCRs are included."
)
createModal("gexAssociation", expl_tbl)

expl_tbl <- tribble(
    ~title, ~content,
    "Knee Plot",
    'Knee Plot was also called as Barcode Rank Plot. The plot shows total UMI (y axis) of each associated barcode (x axis). Foreground cells were selected via cell-calling per "Knee point" as typical scRNAseq experiment, Target (e.g. B/T) cells were further deterimined by their target mRNA UMI (e.g. VDJ UMI) counts (>3). For B or T cells, we retained all the cells either expressing productive or unproductive BCR/TCR mRNAs.'
)
createModal("VDJ_kneePlot", expl_tbl)

expl_tbl <- tribble(
    ~title, ~content,
    "Median IGH UMIs per Cell",
    "Median number of UMIs used to assemble IGH contig.",
    "Median IGK/L UMIs per Cell",
    "Median number of UMIs used to assemble IGK or IGL contig.",
    "Cells with Productive IGH",
    'Number of cells with a productive IGH contig assembled, see below for the definition of the "productive".',
    "Cells with Productive IGK",
    'Number of cells with a productive IGK contig assembled, see below for the definition of the "productive".',
    "Cells with Productive IGL",
    'Number of cells with a productive IGL contig assembled, see below for the definition of the "productive".',
    "Cells with Productive IGKIGH pair",
    'Number of cells with both a productive IGK contig and a productie IGH contig assembled, see below for the definition of the "productive".',
    "Cells with Productive IGLIGH pair",
    'Number of cells with both a productive IGL contig and a productie IGH contig assembled, see below for the definition of the "productive".',
    "Productive",
    "We follow the <a href='https://docs.airr-community.org/en/v1.5.0/datarep/rearrangements.html#productive'><b>AIRR Standards</b></a> to define productive BCR/TCR: <li>Coding region has an open reading frame</li><li>No defect in the start codon, splicing sites or regulatory elements.</li><li>No internal stop codons.</li><li>An in-frame junction region.</li>"
)
createModal("BCR_annotation", expl_tbl)

expl_tbl <- tribble(
    ~title, ~content,
    "Median TRB/TRD UMIs per Cell",
    "Median number of UMIs used to assemble TRB or TRD contig.",
    "Median TRA/TRG UMIs per Cell",
    "Median number of UMIs used to assemble TRA or TRG contig.",
    "Cells with Productive TRB",
    'Number of cells with a productive TRB contig assembled, see below for the definition of the "productive".',
    "Cells with Productive TRD",
    'Number of cells with a productive TRD contig assembled, see below for the definition of the "productive".',
    "Cells with Productive TRA",
    'Number of cells with a productive TRA contig assembled, see below for the definition of the "productive".',
    "Cells with Productive TRG",
    'Number of cells with a productive TRG contig assembled, see below for the definition of the "productive".',
    "Cells with Productive TRATRB pair",
    'Number of cells with both a productive TRA contig and a productie TRB contig assembled, see below for the definition of the "productive".',
    "Cells with Productive TRGTRD pair",
    'Number of cells with both a productive TRG contig and a productie TRD contig assembled, see below for the definition of the "productive".',
    "Productive",
    "We follow the <a href='https://docs.airr-community.org/en/v1.5.0/datarep/rearrangements.html#productive'><b>AIRR Standards</b></a> to define productive BCR/TCR: <li>Coding region has an open reading frame</li><li>No defect in the start codon, splicing sites or regulatory elements.</li><li>No internal stop codons.</li><li>An in-frame junction region.</li>"
)
createModal("TCR_annotation", expl_tbl)

expl_tbl <- tribble(
    ~title, ~content,
    "Clones (Paired)",
    "Here we counted unique CDR3 nucleotides pairs with identical germline VDJ gene segments as different clones. This result includes all the paired ones from the clonotype table.",
    "Lineage Number",
    "Number of the lineages identified from the paired clones. The cells in the same lineage are required to have identical VH and VL germline gene segments and at least 80% nucleotide identity in the CDR-H3 region.",
    "Single Cell Lineage Number",
    "Number of the lineages which have only one cell member.",
    "Multiple Cell Lineage Number",
    "Number of the lineages which have more then one cells.",
    "Cells in Multiple Cell Lineages",
    "Number of the total cells from the multiple cell lineage.",
    "Total Cells with Paired Clones",
    "Total number of the cells taken into the lineage analysis, reuqiring both the VH and VL chains detected.",
    "Pairing Accuracy",
    'The pairing accuracy were estimated under the assumption that all the T/B cells are mature and VDJ recombination steps have been finished. Thus there is very little chance two cells having the same VDJ germline segments on both VH and VL chain. We grouped all the cells with identical heavy chain VDJ and CDRH3 sequence, and identified the cells with disconcordant light chain VDJ segments as "platform pairing error" cells. The percentage of concordant cells was used to estimtate accuracy.',
    "Shannon Entropy & Clonality",
    '<blockquote cite>The Shannon entropy index is a measure used for repertoire diversity using clonotype frequencies, which reflects both richness and evenness of the repertoire. This measure informs us of the probability that two random selections from the same repertoire would represent the same clonotype. Clonality can be measured using normalized entropy over the number of unique clones (1-shannon entropy/log(N), where N is the number of unique clones). It is equivalent to 1 - Pielouâ€™s Evenness, making it inversely proportional to diversity. A higher clonality index indicates an uneven repertoire due to expansion of clones.<footer>https://liulab-dfci.github.io/RIMA/Repertoire.html#tcr-and-bcr-entropy-and-clonality</footer></blockquote>'
)
createModal("Lineage_annotation", expl_tbl)


expl_tbl <- tribble(
    ~title, ~content,
    "Pie Chart",
    "Pie chart summarized percentage of cells in expanded lineages (blue) and cells in singleton lineage (grey).",
    "Bar Chart",
    "Bar chart summarized cell counts in up to top 50 expanded lineages."
)
createModal("Lineage_plot", expl_tbl)

expl_tbl <- tribble(
    ~title, ~content,
    "V Region Coverage",
    "UMI or Read coverage for assembled VH or VL contigs. Positions within VH and VL are based on IMGT scheme numbers, CDR regions are indicated by shaded regions. Solid lines indicate the median, dashed lines interquartile range."
)
createModal("Chain_coverage", expl_tbl)

expl_tbl <- tribble(
    ~title, ~content,
    "Top 1000 Clonotypes",
    "Clonotypes are defined as the same VH and VL CDR3 <b>nucleotide</b> sequences as well as identical VDJ combinations. Here cells generating unproductive chain or with only one chain detected are also included. If multiple heavy or light chain contigs were obtained, only the most abundant one will be shown."
)
createModal("Clonetypes_top1000", expl_tbl)

expl_tbl <- tribble(
    ~title, ~content,
    "Top 10 Clonotypes",
    "The histogram depicts cell counts of the top 10 abundant clonotypes. Clonotypes with only one chain detected or from unproductive chain are also included. The clonotype IDs on the X axis correspond to the clonotype IDs listed in the table."
)
createModal("Clonetypes_top10", expl_tbl)

expl_tbl <- tribble(
    ~title, ~content,
    "Estimated Number of Cells",
    "The number of detected cells expressing VDJ transcripts. We used VDJ UMI > 3 to filter background barcodes, and cells with either productive or unproductive VDJ chains are counted.",
    "Reads in Cells Mapped to VDJ Gene",
    "Number of reads with valid barcodes in the estimated cells that map to any germline V(D)J gene segment and used for VDJ contig assembly.",
    "Fraction of Reads Used in Assembly",
    "Fraction of reads with valid barcodes in the estimated cells that map to any germline V(D)J gene segment and used for VDJ contig assembly.",
    "Mean VDJ Reads per Cell",
    "Number of VDJ reads in the estimated VDJ cells divided by cell counts.",
    "Median VDJ Reads per Cell",
    "Median number of the VDJ reads in the estimated cells.",
    "Mean Total UMIs per Cell",
    "Number of the total UMIs (VDJ UMI + none-VDJ UMI) in the estimated VDJ cells divided by cell counts.",
    "Median Total UMIs per Cell",
    "Median of the total UMIs (VDJ UMI + none-VDJ UMI) in the estimated VDJ cells.",
    "Pairing Rate",
    "The number of detected cells expressing both heavy chain and light chain transcripts divided by the total number of cells.",
    "Total Clonotypes Detected",
    "Number of clonotypes detected. Clonotypes are defined as the same VH and VL CDR3 amino acid sequences as well as identical VDJ combinations."
)
createModal("VDJ_stats", expl_tbl)

expl_tbl <- tribble(
    ~title, ~content,
    "Number of Reads",
    "Number of the input reads after trimming low quality (Q30) bases from cDNA reads and discarding reads that are too short.",
    "Reads With Valid Barcodes",
    "Fraction of reads with a valid barcode in the whitelist after barcodes correction.",
    "Sequencing Saturation",
    "Sequencing saturation is estimated by counting reads belonging to the same UMI, which is an indicator of the library complexity. A 75% saturation indicates that user will have to sequence 4 more reads to obtain a new UMI (mRNA transcript).",
    "Q30 Bases in CB+UMI",
    "Fraction of the CB+UMI reads bases with Q-score >= 30, indicating 99.9% sequence accuracy.",
    "Q30 Bases in RNA read",
    "Fraction of the cDNA reads bases with Q-score >= 30, indicating 99.9% sequence accuracy."
)
createModal("Sequencing_stats", expl_tbl)
```


`r if(!include_gex){"\\begin{comment}"} else {NULL}`

```{r process_gex, include = FALSE, eval = include_gex}
is_number_string <- function(x){
    str_split(x, pattern="") %>% 
        unlist %>% str_detect("[0-9.]") %>% 
        all()
}
starsolo_summary <- read_csv(params$starsolo_out,
                             col_names = c("item", "value"),
                             col_types = cols("c", "c"))
starsolo_summary$data <- NA
for(i in 1:nrow(starsolo_summary)){
    if(is_number_string(starsolo_summary$value[i])){
        if(as.numeric(starsolo_summary$value[i]) >= 1){
            starsolo_summary$data[i] <- comma(as.numeric(starsolo_summary$value[i]), accuracy = 1)
        }else{
            starsolo_summary$data[i] <- percent(as.numeric(starsolo_summary$value[i]))
        }
    }else{
        starsolo_summary$data[i] <- starsolo_summary$value[i]
    }
}
starsolo_summary <- starsolo_summary %>%
    select(-value) %>%
    dplyr::rename("value" = "data") %>%
    mutate(item=str_replace_all(item, "GeneFull", "Gene"))
exon_cmd <- paste0("grep 'exonic' ", params$qualimap_out, " | awk '{print $NF}' | sed 's/(//; s/)//'")
exon_ratio <- system(exon_cmd, intern = TRUE)

intron_cmd <- paste0("grep 'intron' ", params$qualimap_out, " | awk '{print $NF}' | sed 's/(//; s/)//'")
intron_ratio <- system(intron_cmd, intern = TRUE)

STARSolo <- Read10X(data.dir=file.path(params$starsolo_matrixDir))
seuratData <- CreateSeuratObject(counts=STARSolo,
                             min.cells=0,
                             min.features=0, project=params$sampleName)
seuratData[['run']]=params$sampleName
seuratData[["percent.mt"]]=PercentageFeatureSet(object=seuratData, pattern = "MT-|mt-")

## save a raw loom file
SaveH5Seurat(
    seuratData, 
    filename = paste0(params$sampleName, ".raw.h5seurat"), 
    overwrite = TRUE,
    verbose = FALSE
)

## Plot the genes counts, RNAs counts and mitochondrial proportions.
qcPlot <- VlnPlot(object=seuratData, features=c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol=3, group.by="run")

## Filter by gene counts and mitochondrial percentage
## Check the number of cells left first, or subset will throw an error
filtered_cells <- seuratData@meta.data %>% 
    filter(nFeature_RNA > max(200, as.numeric(params$nFeature_RNA_lower)),
           percent.mt < as.numeric(params$percent_mt_cutoff)) %>% 
           nrow
message("filtered_cells is ", filtered_cells)
if(filtered_cells>0){
    seuratData <- subset(
        seuratData, 
        nFeature_RNA > as.numeric(params$nFeature_RNA_lower) & percent.mt < as.numeric(params$percent_mt_cutoff)
    )
    filtered_cells <- seuratData@meta.data %>% nrow
}

## Only perform clustering when more than 150 cells detected
if(filtered_cells >= 150){
    ## Normalization and scaling
    ##seuratData <- NormalizeData(object=seuratData)
    ##seuratData <- FindVariableFeatures(seuratData)
    ##seuratData <- ScaleData(seuratData, vars.to.regress=c("nCount_RNA", "percent.mt"), features=rownames(seuratData))
    
    ## replace above commands with sctransform
    ## default use top 3000 variable features
    seuratData <- SCTransform(seuratData, vars.to.regress = "percent.mt", conserve.memory = TRUE)
    
    seuratData <- RunPCA(object=seuratData, npcs=100)
    
    ## set pca_dim to be used, 30
    pca_dim <- as.numeric(params$pca_dim)
    ## set resolution
    resolution <- as.numeric(params$resolution)
    
    seuratData <- FindNeighbors(object=seuratData, reduction="pca", dims=1:pca_dim)
    seuratData <- FindClusters(object=seuratData, resolution=resolution)
    seuratData <- RunUMAP(object=seuratData, reduction="pca", dims=1:pca_dim)
    
    ##Idents(object=seuratData) <- paste("RNA_snn_res.", resolution, sep="")
    ##clusterPlot <- DimPlot(object=seuratData, reduction="umap", label=TRUE, repel=TRUE)
}
```



GEX {data-orientation=rows}
====================

<h2 style="margin-top: 0.5rem; font-weight: bold;">Sample: `r params$sampleName` (GEX)</h2>

Row
----------

### Estimated Number of Cells

```{r eval = include_gex}
cellNum <- starsolo_summary %>% 
    filter(item == "Estimated Number of Cells") %>% 
    pull(value)
valueBox(cellNum, icon = "fa-circle-notch", color = "info")
```

### Mean Reads per Cell

```{r eval = include_gex}
readsMean <- starsolo_summary %>% 
    filter(item == "Mean Reads per Cell") %>% 
    pull(value)
valueBox(readsMean, icon = "fa-chart-bar", color = "primary")
```

### Median Genes per Cell

```{r eval = include_gex}
medianGenePerCell <- starsolo_summary %>% 
    filter(str_detect(item, regex("Median Gene(Full)* per Cell"))) %>% 
    pull(value)
valueBox(medianGenePerCell, icon = "fa-barcode", color = "warning")
```

Row
----------

### Cell Stats

```{r eval = include_gex}
d <- starsolo_summary %>% 
    filter(item %in% c("Estimated Number of Cells",
                       "Unique Reads in Cells Mapped to Gene",
                       "Unique Reads in Cells Mapped to GeneFull",
                       "Reads in Cells Mapped to Gene",
                       "Fraction of Unique Reads in Cells",
                       "Fraction of Reads in Cells",
                       "Mean Reads per Cell",
                       "Median Reads per Cell",
                       "UMIs in Cells",
                       "Mean UMI per Cell",
                       "Median UMI per Cell",
                       "Mean Gene per Cell",
                       "Mean GeneFull per Cell",
                       "Median Gene per Cell",
                       "Median GeneFull per Cell",
                       "Total Gene Detected",
                       "Total GeneFull Detected"))
names(d) <- c("","")                       
d %>% kbl() %>% kable_paper("hover", html_font = "arial, helvetica, sans-serif")
```

### Knee Plot

```{r eval = include_gex}
umi_dist <- read_tsv(params$starsolo_bc, col_names =c("UMI"))
cellNum <- str_replace(cellNum, ",", "") %>% as.numeric()
umi_dist <-  umi_dist %>%
    mutate(
        cell = c(1:nrow(umi_dist)),
        group = case_when(
            cell <= cellNum ~ "cell",
            TRUE ~ "background"
            )
        )

fig <- plot_ly(data = umi_dist, x = ~cell, y = ~UMI, type = 'scatter', mode = 'lines',
               color = ~group, colors = c('grey', '#002366'),
               hovertemplate = 'UMI: %{y}<extra>%{fullData.name}</extra>',
               line = list(width = 3),
               height = 400, width = 360)
fig <- layout(fig, xaxis = list(title = "Barcode Rank", type = "log"),yaxis = list(type = "log"), showlegend = FALSE)
config_plotly_fig(fig) %>% toWebGL()

##ggplot(umi_dist, aes(x=cell, y=UMI, color = group)) + 
##    geom_point(alpha = 0.8) +
##    geom_vline(xintercept = cellNum, 
##               linetype = "dashed", color = "grey") +
##    scale_x_log10(n.breaks = 8, labels = scales::label_number_si()) + 
##    scale_y_log10(n.breaks = 5, labels = scales::label_number_si()) +
##    scale_color_manual(values =c("grey", "royalblue")) +
##    xlab("Cell") + ylab("UMI") +
##    theme_bw() + 
##    theme(panel.grid = element_blank(), 
##          axis.text = element_text(color="black"),
##          legend.position = "none")
```

Row {data-height=400}
----------

### Sequencing Stats

```{r eval = include_gex}
d <- starsolo_summary %>% 
    filter(item %in% c("Number of Reads",
                       "Reads With Valid Barcodes",
                       "Sequencing Saturation",
                       "Q30 Bases in CB+UMI",
                       "Q30 Bases in RNA read",
                       "Total Gene Detected",
                       "Total GeneFull Detected"))
names(d) <- c("","")
d %>% kbl() %>% kable_paper("hover", html_font = "arial, helvetica, sans-serif")
                                        
```

### Mapping Stats

```{r eval = include_gex}
d <- starsolo_summary %>% 
    filter(item %in% c("Reads Mapped to Genome: Unique+Multiple",
                       "Reads Mapped to Genome: Unique",
                       "Reads Mapped to Gene: Unique+Multiple Gene",
                       "Reads Mapped to GeneFull: Unique+Multiple GeneFull",
                       "Reads Mapped to Gene: Unique Gene",
                       "Reads Mapped to GeneFull: Unique GeneFull")) %>%
    add_row(item = "Reads Mapped to Exonic Regions", value = exon_ratio) %>%
    add_row(item = "Reads Mapped to Intronic Regions", value = intron_ratio)
names(d) <- c("","")
d %>% kbl() %>% kable_paper("hover", html_font = "arial, helvetica, sans-serif")
```

Row
----------

### Cell Cluster (colored by cell group)

```{r eval = include_gex}
## Only plot cluster when there are more than 150 filtered cells
if(filtered_cells >= 150){
    ##clusterPlot <- DimPlot(object=seuratData, reduction="umap", label=TRUE, repel=TRUE)
    ## extract data from seuratData
    umap_data <- Embeddings(object = seuratData[["umap"]])[colnames(seuratData), c(1, 2)]
    clusterData <- merge(umap_data, seuratData@meta.data, by=0) %>% 
        dplyr::rename("bc" = `Row.names`)
    cellCount <- clusterData %>% group_by(seurat_clusters) %>% summarise(cellCount = n())
    totalCell <- cellCount %>% pull(cellCount) %>% sum()
    clusterData <- clusterData %>% left_join(cellCount, by = "seurat_clusters") %>%
        mutate(totalCell=totalCell,
               text = paste0(cellCount, "/", totalCell))
    
    plot_ly(clusterData, x = ~UMAP_1, y= ~UMAP_2, color = ~seurat_clusters, 
            text = ~text,
            type = 'scatter', mode = 'markers',
            colors = 'Dark2',
            hovertemplate = 'cells: %{text}<extra><b>Cluster: %{fullData.name}</b></extra>') %>%
        config_plotly_fig() %>%
        toWebGL()
    
    ##clusterPlot %>% ggplotly() %>%
    ##    config(displaylogo = FALSE,
    ##           modeBarButtonsToRemove = c('zoom', 'pan', 'select', 'zoomIn', 'zoomOut', 'autoScale',
    ##                                      'hoverClosestCartesian', 'hoverCompareCartesian')) %>% toWebGL()
}else{
    cat("Too few cells: ", filtered_cells, "(filtered by nFeature >= 200)\n")
}
```

### Cell Cluster (colored by read depth)

```{r eval = include_gex}
if(filtered_cells >= 150){
clusterData <- clusterData %>%
    mutate(log10_UMI = log10(nCount_RNA))
    
plot_ly(clusterData, x = ~UMAP_1, y= ~UMAP_2, color = ~log10_UMI,  text = ~nCount_RNA,
        type = 'scatter', mode = 'markers',
        hovertemplate = 'UMI: %{text}<extra></extra>') %>%
    config_plotly_fig() %>%
    toWebGL()

##depthPlot <- FeaturePlot(object = seuratData, features = 'log_nCount_RNA') + scale_color_continuous(name="log10 Read Counts", type = "viridis", direction = 1) + labs(title = NULL)
##depthPlot %>% ggplotly() %>%
##    config(displaylogo = FALSE, 
##           modeBarButtonsToRemove = c('zoom', 'pan', 'select', 'zoomIn', 'zoomOut', 'autoScale',
##                                      'hoverClosestCartesian', 'hoverCompareCartesian')) %>% toWebGL()
}else{
    cat("Too few cells: ", filtered_cells, "(filtered by nFeature >= 200)\n")
}
```

Row {style="margin-right: 8px"}
----------

### Marker Genes of Clusters (top5) {style="width: 100% !important"}

```{r eval = include_gex}
if(filtered_cells >= 150){
    markerGenes <- FindAllMarkers(seuratData, only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25)
    if("cluster" %in% colnames(markerGenes)){
        markerGenes %>%
            group_by(cluster) %>%
            slice_max(n = 5, order_by = avg_log2FC) %>% 
            dplyr::relocate(gene, .before=1) %>%
            mutate(p_val = signif(p_val, 3),
                   avg_log2FC = signif(avg_log2FC, 3),
                   p_val_adj = signif(p_val_adj, 3)) %>%
            DT::datatable(rownames = FALSE, width = "100%",
                          options = list(scrollX = T, scrollY = F, pageLength = 10))
    }else{
        cat("No DEGs detected.\n")
    }
}else{
    cat("Too few cells: ", filtered_cells, "(filtered by nFeature >= 200)\n")
}
```

```{r include=FALSE, eval = include_gex}
if(filtered_cells >= 150 && ("cluster" %in% colnames(markerGenes))){
    markerGenes %>%
        group_by(cluster) %>%
        dplyr::relocate(gene, .before=1) %>%
        write_tsv(paste0(params$sampleName, "_DEG.tsv"))
}
```

Row
----------

### Cell Metrics

```{r eval = include_gex}
qcPlot
```

### Gene Coverage

```{r eval = include_gex}
read_tsv(params$qualimap_gene_coverage) %>%
    ggplot(aes(x=`#Transcript position`, y=`Transcript coverage profile`)) +
    geom_line(size=1, color = "#551a8b", alpha=0.8) +
    scale_y_continuous(labels = label_comma()) +
    theme_bw() + theme(panel.grid = element_blank())
```


Row
----------

### Sequencing Saturation

```{r eval = include_gex}
saturation_data <- fromJSON(params$saturation_json)
saturation_data <- saturation_data[["saturation_data"]] %>%
    as_tibble() %>%
    mutate(across(.col = everything(), .fns = as.numeric))

plot_ly(saturation_data, x = ~reads, y= ~saturation,
        type = 'scatter', mode = 'lines',
        hovertemplate = 'Read depth: %{x}<br>Saturation: %{y}<extra></extra>') %>%
    config_plotly_fig() %>%
    toWebGL()
```

### Median Genes per Cell

```{r eval = include_gex}
plot_ly(saturation_data, x = ~meanReadPerCell, y= ~medianGenePerCell,
        type = 'scatter', mode = 'lines',
        hovertemplate = 'Mean read per cell: %{x}<br>Median gene per cell: %{y}<extra></extra>') %>%
    config_plotly_fig() %>%
    toWebGL()
```

```{r include=FALSE, eval = include_gex}
starsolo_summary %>% 
    filter(item %in% c("Estimated Number of Cells",
                       "Unique Reads in Cells Mapped to Gene",
                       "Unique Reads in Cells Mapped to GeneFull",
                       "Fraction of Unique Reads in Cells",
                       "Mean Reads per Cell",
                       "Median Reads per Cell",
                       "UMIs in Cells",
                       "Mean UMI per Cell",
                       "Median UMI per Cell",
                       "Mean Gene per Cell",
                       "Mean GeneFull per Cell",
                       "Median Gene per Cell",
                       "Median GeneFull per Cell",
                       "Total Gene Detected",
                       "Total GeneFull Detected",
                       "Number of Reads",
                       "Reads With Valid Barcodes",
                       "Sequencing Saturation",
                       "Q30 Bases in CB+UMI",
                       "Q30 Bases in RNA read",
                       "Reads Mapped to Genome: Unique+Multiple",
                       "Reads Mapped to Genome: Unique",
                       "Reads Mapped to Gene: Unique+Multiple Gene",
                       "Reads Mapped to GeneFull: Unique+Multiple GeneFull",
                       "Reads Mapped to Gene: Unique Gene",
                       "Reads Mapped to GeneFull: Unique GeneFull")) %>%
    add_row(item = "Reads Mapped to Exonic Regions", value = exon_ratio) %>%
    add_row(item = "Reads Mapped to Intronic Regions", value = intron_ratio) %>%
    mutate(sampleID=params$sampleName) %>% 
    pivot_wider(sampleID, names_from = item, values_from= value) %>% 
    write_json(paste0(params$sampleName, ".metrics.json"), pretty=TRUE)
```

`r if(!include_gex) {"\\end{comment}"} else {NULL}`

`r if(!include_tcr) {"\\begin{comment}"} else {NULL}`

VDJ-T {data-orientation=rows}
====================

<h2 style="margin-top: 0.5rem; font-weight: bold;">Sample: `r params$sampleName` (VDJ-T)</h2>

```{r include=FALSE, eval = include_tcr}
vdj_t_cells <- read_tsv(params$VDJ_T_cells)
vdj_t_combinedInfo <- combineInfo(cells = vdj_t_cells$CB, 
                                  barcode_report = params$VDJ_T_report,
                                  airr_report = params$VDJ_T_airr)

vdj_t_cloneType <- vdj_t_combinedInfo %>%
    dplyr::select(chain1_cdr3aa, chain2_cdr3aa, chain1_V, chain1_D, chain1_J, chain2_V, chain2_J) %>%
    group_by(chain1_cdr3aa, chain2_cdr3aa, chain1_V, chain1_D, chain1_J, chain2_V, chain2_J) %>%
    summarize(cellCount = n()) %>%
    ungroup() %>%
    mutate(
        label1 = case_when(
            !is.na(chain1_V) ~ str_sub(chain1_V, 1L, 3L),
            !is.na(chain1_D) ~ str_sub(chain1_D, 1L, 3L),
            !is.na(chain1_J) ~ str_sub(chain1_J, 1L, 3L),
            TRUE ~ "Heavy"
        ),
        label2 = case_when(
            !is.na(chain2_V) ~ str_sub(chain2_V, 1L, 3L),
            !is.na(chain2_J) ~ str_sub(chain2_J, 1L, 3L),
            TRUE ~ "Light"
        ),
        Hchain_VDJ = paste0(chain1_V, "|", chain1_D, "|", chain1_J),
        Lchain_VDJ = paste0(chain2_V, "|", chain2_J)
    ) %>%
    mutate(
        cloneType = case_when(
            !is.na(chain1_cdr3aa) & !is.na(chain2_cdr3aa) ~ paste0(label1, ":", chain1_cdr3aa, ";", label2, ":", chain2_cdr3aa),
            is.na(chain1_cdr3aa) ~ paste0(label2, ":", chain2_cdr3aa),
            is.na(chain2_cdr3aa) ~ paste0(label1, ":", chain1_cdr3aa)
        )
    ) %>%
    arrange(desc(cellCount)) %>%
    mutate(Frequency = cellCount/nrow(vdj_t_combinedInfo)) %>%
    dplyr::select(cloneType, Hchain_VDJ, Lchain_VDJ, cellCount, Frequency)

vdj_t_cloneType$Hchain_VDJ[which(vdj_t_cloneType$Hchain_VDJ == "NA|NA|NA")] <- NA
vdj_t_cloneType$Lchain_VDJ[which(vdj_t_cloneType$Lchain_VDJ == "NA|NA")] <- NA
    
vdj_t_cloneType <- vdj_t_cloneType %>%
    mutate(
        id = 1:nrow(vdj_t_cloneType),
        Frequency = scales::label_percent(0.01)(Frequency)
    )
write_tsv(vdj_t_combinedInfo, file = paste0(params$sampleName, "_TCR_results.tsv"))
write_tsv(vdj_t_cloneType, file = paste0(params$sampleName, "_TCR_clonotypes.tsv"))
```

Row
----------

### Estimated Number of Cells


```{r include = FALSE, eval = include_tcr}
vdj_t_metrics <- fromJSON(params$VDJ_T_metrics)
```

```{r eval = include_tcr}
valueBox(vdj_t_metrics$cells %>% as.numeric() %>% label_comma()(), icon = "fa-circle-notch", color = "info")
```

### Mean VDJ Reads per Cell

```{r eval = include_tcr}
valueBox(vdj_t_metrics$meanVDJReadsPerCell %>% as.numeric() %>% round %>% label_comma()(), icon = "fa-chart-bar", color = "primary")
```

### Total Clonotypes Discovered

```{r eval = include_tcr}
valueBox(nrow(vdj_t_cloneType) %>% label_comma()(), icon = "fa-barcode", color = "warning")
```

Row
----------

### VDJ Stats `r infoIcon("VDJ_stats")`

```{r eval = include_tcr}
##Estimated Number of Cells
##Reads in Cells Mapped to Gene
##Fraction of Reads in Cells
##Mean Reads per Cell
##Median Reads per Cell
##UMIs in Cells
##Mean UMI per Cell
##Median UMI per Cell
##Mean Gene per Cell
##Median Gene per Cell

fractionAssembled <- as.numeric(vdj_t_metrics$totalReadsInCell)/(as.numeric(vdj_t_metrics$totalRawReads)*as.numeric(vdj_t_metrics$validBCreads))
fractionAssembled <- as.character(fractionAssembled)

vdj_t_tbl <- tribble(
  ~term, ~value,
  "Estimated Number of Cells (including non-pairing cells)", vdj_t_metrics$cells,
  "Reads in Cells Mapped to VDJ Gene", vdj_t_metrics$totalReadsInCell,
  "Fraction of Reads Used in Assembly", fractionAssembled,
  "Mean VDJ Reads per Cell", vdj_t_metrics$meanVDJReadsPerCell,
  "Median VDJ Reads per Cell", vdj_t_metrics$medianVDJReadsPerCell,
  "Mean Total UMIs per Cell", vdj_t_metrics$meanTotalUMIsPerCell,
  "Median Total UMIs per Cell", vdj_t_metrics$medianTotalUMIsPerCell,
  "Pairing Rate", vdj_t_metrics$pairingRate,
  "Total Clonotypes Detected", vdj_t_metrics$totalCloneTypes
) %>%
  mutate(value = as.numeric(value)) %>%
  mutate(value=case_when(value <= 1 ~ label_percent(0.01)(value),
                         value > 1 ~ label_comma()(round(value))))
                         
## Rename UMI terms
if(!params$withUMI){
    vdj_t_tbl$term[which(vdj_t_tbl$term=="Mean Total UMIs per Cell")] <- "Mean Total Reads per Cell"
    vdj_t_tbl$term[which(vdj_t_tbl$term=="Median Total UMIs per Cell")] <- "Median Total Reads per Cell"
}

vdj_t_stats <- vdj_t_tbl

names(vdj_t_tbl) <- c("", "")
vdj_t_tbl %>% 
    kbl() %>% 
    kable_paper("hover", html_font = "arial, helvetica, sans-serif")
```

### Knee Plot `r infoIcon("VDJ_kneePlot")`

```{r eval = include_tcr}
cellNum <- as.numeric(vdj_t_metrics$cells)
vdj_t_kneeData <- read_tsv(params$VDJ_T_kneeOut, col_names = c("CB", "UMI"))

vdj_t_knee <- vdj_t_kneeData %>% 
    mutate(
        cell = c(1:nrow(vdj_t_kneeData)),
        group = case_when(
            CB %in% vdj_t_cells$CB ~ "cell",
            TRUE ~ "background"
        )
    )
fig <- plot_ly(data = vdj_t_knee, x = ~cell, y = ~UMI, type = 'scatter', mode = 'lines',
               color = ~group, colors = c('grey', '#002366'),
               hovertemplate = 'UMI: %{y}<extra>%{fullData.name}</extra>',
               line = list(width = 3),
               height = 400, width = 360)
fig <- layout(fig, xaxis = list(title = "Barcode Rank", type = "log"),yaxis = list(type = "log"), showlegend = FALSE)

if(!params$withUMI){
    fig <- layout(fig, yaxis = list(title = "Reads"))
}

config_plotly_fig(fig) %>% toWebGL()
```

Row {data-height=350}
----------

### Sequencing Stats `r infoIcon("Sequencing_stats")`

```{r eval = include_tcr}
##Number of Reads
##Reads With Valid Barcodes
##Sequencing Saturation
##Q30 Bases in CB+UMI
##Q30 Bases in RNA read
##Total VDJ Gene Fragments Detected
vdj_t_tbl <- tribble(
  ~term, ~value,
  "Number of Reads", vdj_t_metrics$totalRawReads,
  "Reads With Valid Barcodes", vdj_t_metrics$validBCreads,
  "Sequencing Saturation", vdj_t_metrics$saturation,
  "Q30 Bases in CB+UMI", vdj_t_metrics$q30InCBandUMI,
  "Q30 Bases in RNA read", vdj_t_metrics$q30InRNA
) %>%
  mutate(value = as.numeric(value)) %>%
  mutate(value=case_when(value <= 1 ~ label_percent(0.01)(value),
                         value > 1 ~ label_comma()(round(value))))
                         
vdj_t_sequencing_stats <- vdj_t_tbl

names(vdj_t_tbl) <- c("", "")
vdj_t_tbl %>% 
    kbl() %>% 
    kable_paper("hover", html_font = "arial, helvetica, sans-serif")
```

### V(D)J Annotation `r infoIcon("TCR_annotation")`

```{r eval = include_tcr}
##Cells with productive V-J spanning pair
##Cells with productive V-J spanning (IGK, IGH) pair
##Cells with productive V-J spanning (IGL, IGH) pair
##Cells with productive IGH contig
##Cells with productive IGK contig
##Cells with productive IGL contig
##Paired clonotype diversity
medianUMIsChain1 <- vdj_t_combinedInfo %>% 
    pull(chain1_expr) %>% median(na.rm = TRUE) %>% round()
medianUMIsChain2 <- vdj_t_combinedInfo %>%
    pull(chain2_expr) %>% median(na.rm = TRUE) %>% round()
cellsWithProductiveChainTRB <- vdj_t_combinedInfo %>%
    filter(chain1_productive, chain1_type == "TRB") %>% nrow()
cellsWithProductiveChainTRA <- vdj_t_combinedInfo %>%
    filter(chain2_productive, chain2_type == "TRA") %>% nrow()
cellsWithProductiveChainTRD <- vdj_t_combinedInfo %>%
    filter(chain1_productive, chain1_type == "TRD") %>% nrow()
cellsWithProductiveChainTRG <- vdj_t_combinedInfo %>%
    filter(chain2_productive, chain2_type == "TRG") %>% nrow()
cellsWithProductiveChainTRATRB <- vdj_t_combinedInfo %>%
    filter(chain1_productive, 
           chain2_productive, 
           chain1_type == "TRB", 
           chain2_type == "TRA") %>% 
    nrow()
cellsWithProductiveChainTRGTRD <- vdj_t_combinedInfo %>%
    filter(chain1_productive, 
           chain2_productive, 
           chain1_type == "TRD", 
           chain2_type == "TRG") %>% 
    nrow()

vdj_t_tbl <- tribble(
  ~term, ~value,
  "Median TRB/TRD UMIs per Cell", medianUMIsChain1,
  "Median TRA/TRG UMIs per Cell", medianUMIsChain2,
  "Cells with Productive TRB", cellsWithProductiveChainTRB,
  "Cells with Productive TRD", cellsWithProductiveChainTRD,
  "Cells with Productive TRA", cellsWithProductiveChainTRA,
  "Cells with Productive TRG", cellsWithProductiveChainTRG,
  "Cells with Productive TRATRB pair", cellsWithProductiveChainTRATRB,
  "Cells with Productive TRGTRD pair", cellsWithProductiveChainTRGTRD
) %>%
  mutate(value = as.numeric(value)) %>%
  mutate(value = label_comma()(round(value)))

vdj_t_annotation <- vdj_t_tbl

names(vdj_t_tbl) <- c("", "")
vdj_t_tbl %>% 
    kbl() %>% 
    kable_paper("hover", html_font = "arial, helvetica, sans-serif")
```

Row
----------

### GEX Association `r infoIcon("gexAssociation")`

```{r eval = (include_tcr & include_gex)}
## Only plot cluster when there are more than 150 filtered cells
if(filtered_cells >= 150){
    ##clusterPlot <- DimPlot(object=seuratData, reduction="umap", label=TRUE, repel=TRUE)
    ## extract data from seuratData
    tcr_cdrSeq <- read_tsv(params$VDJ_T_report) %>%
        select(`#barcode`, `chain1`, `chain2`)
    tcr_cdrSeq$chain1_cdr3 <- ""
    tcr_cdrSeq$chain2_cdr3 <- ""
    for(i in 1:nrow(tcr_cdrSeq)){
        tcr_cdrSeq$chain1_cdr3[i] <- unlist(strsplit(tcr_cdrSeq$chain1[i], ","))[6]
        tcr_cdrSeq$chain2_cdr3[i] <- unlist(strsplit(tcr_cdrSeq$chain2[i], ","))[6]
    }
    
    tcr_cells <- vdj_t_knee %>%
        filter(group == "cell") %>%
        pull(CB)
    tcr_data <- vdj_t_kneeData %>%
        filter(CB %in% tcr_cells) %>%
        left_join(tcr_cdrSeq, by = c("CB" = "#barcode"))
    clusterData2 <- clusterData %>% left_join(tcr_data, by = c("bc" = "CB")) %>%
        dplyr::select(bc, UMAP_1, UMAP_2, chain1_cdr3, chain2_cdr3) %>%
        dplyr::mutate(
            text = paste0(chain1_cdr3, "+", chain2_cdr3),
            type = case_when(
                !is.na(chain1_cdr3) & !is.na(chain2_cdr3) ~ "Detected",
                TRUE ~ "Not captured"
            )
        )

    plot_ly(clusterData2, x = ~UMAP_1, y= ~UMAP_2, color = ~type, 
            text = ~text,
            type = 'scatter', mode = 'markers',
            marker = list(opacity = 0.5),
            colors = c("#9370DB", "grey"),
            hovertemplate = 'CDR3: %{text}<extra><b>Type: %{fullData.name}</b></extra>') %>%
        config_plotly_fig() %>%
        toWebGL()
    
    ##clusterPlot %>% ggplotly() %>%
    ##    config(displaylogo = FALSE,
    ##           modeBarButtonsToRemove = c('zoom', 'pan', 'select', 'zoomIn', 'zoomOut', 'autoScale',
    ##                                      'hoverClosestCartesian', 'hoverCompareCartesian')) %>% toWebGL()
}else{
    cat("Too few cells: ", filtered_cells, "(filtered by nFeature >= 200)\n")
}
```

```{r eval = !(include_tcr & include_gex)}
cat("No gene expression library\n")
```

### Top 10 Clonotypes `r infoIcon("Clonetypes_top10")`

```{r eval = include_tcr}
fig <- plot_ly(data = vdj_t_cloneType %>% filter(id<=10), x = ~id, y = ~cellCount, type = "bar")
fig <- layout(fig, showlegend = FALSE)
config_plotly_fig(fig)
```

Row {style="margin-right: 8px"}
----------

### Identified Clonetypes (top 1000) `r infoIcon("Clonetypes_top1000")` {style="width: 100% !important"} 

```{r eval = include_tcr}
vdj_t_cloneType %>%
    filter(id <= 1000) %>%
    DT::datatable(rownames = FALSE, width = "100%",
                  options = list(scrollX = T, scrollY = F, pageLength = 10))
```

Row {data-height=400}
----------

### V Region Coverage (Chain1) `r infoIcon("Chain_coverage")`

```{r eval = include_tcr, fig.width = 7, fig.height = 4}
coverage_plots <- plot_VDJ_coverage(
    cells = vdj_t_cells$CB, 
    barcode_report = params$VDJ_T_report, 
    airr_report = params$VDJ_T_airr, 
    trust4_final_out = params$VDJ_T_finalOut, 
    type = "VDJ-T"
)
coverage_plots$chain1_plot
```

### V Region Coverage (Chain2) `r infoIcon("Chain_coverage")`


```{r eval = include_tcr, fig.width = 7, fig.height = 4}
coverage_plots$chain2_plot
```

Row {data-height=400}
----------

### Lineage & CloneType Stats `r infoIcon("Lineage_annotation")`

```{r eval = include_tcr}
tcr_lineageInfo <- getLineage(cells = vdj_t_cells$CB,
                              barcode_report = params$VDJ_T_report,
                              airr_report = params$VDJ_T_airr)
                              
write_tsv(tcr_lineageInfo, file = paste0(params$sampleName, "_TCR_results.productiveOnly_withLineage.tsv"))

tcr_pairing_clones <- tcr_lineageInfo %>%
    select(chain1_V, chain1_D, chain1_J, chain1_cdr3,
           chain2_V, chain2_J, chain2_cdr3) %>%
    na.omit() %>%
    distinct() %>%
    nrow()
tcr_lineage_number <- tcr_lineageInfo %>%
    pull(lineageName) %>%
    unique() %>% length()
multipleLineageCellNumber <- tcr_lineageInfo %>%
    filter(lineageType == "multiple") %>%
    nrow()
multipleCellLineageNumber <- tcr_lineageInfo %>%
    filter(lineageType == "multiple") %>%
    pull(lineageName) %>%
    unique() %>% length()
singleCellLineageNumber <- tcr_lineageInfo %>%
    filter(lineageType == "single") %>%
    pull(lineageName) %>%
    unique() %>% length()

pairingAccuracy <- calc_pairing_accuracy(tcr_lineageInfo)
entropy <- getEntropy(tcr_lineageInfo)
clonality <- getClonality(entropy, tcr_pairing_clones)


lineage_tbl <- tribble(
    ~term, ~value,
    "Clones (Paired)", label_comma()(tcr_pairing_clones),
    "Lineage Number", label_comma()(tcr_lineage_number),
    "Single Cell Lineage Number", label_comma()(singleCellLineageNumber),
    "Multiple Cell Lineage Number", label_comma()(multipleCellLineageNumber),
    "Cells in Multiple Cell Lineages", label_comma()(multipleLineageCellNumber),
    "Total Cells with Paired Clones", label_comma()(nrow(tcr_lineageInfo)),
    "Pairing Accuracy", label_percent(0.01)(pairingAccuracy),
    "Shannon Entropy", label_number(0.001)(entropy),
    "Clonality", label_number(0.001)(clonality)
)

vdj_t_metrics_final <- bind_rows(
    vdj_t_stats,
    vdj_t_sequencing_stats,
    vdj_t_annotation,
    lineage_tbl
)

write_tsv(vdj_t_metrics_final,
          paste0(params$sampleName, "_VDJ-T.metrics.tsv"), 
          col_names=FALSE)

vdj_t_metrics_final %>%
    split(vdj_t_metrics_final$term) %>% 
    lapply(FUN=function(x) { x$value }) %>% 
    write_json(paste0(params$sampleName, "_VDJ-T.metrics.json"), pretty = TRUE, auto_unbox = TRUE)

names(lineage_tbl) <- c("", "")
lineage_tbl %>% 
    kbl() %>% 
    kable_paper("hover", html_font = "arial, helvetica, sans-serif")
```

### Lineage Plots `r infoIcon("Lineage_plot")`

```{r eval = include_tcr, fig.width = 7, fig.height=3.5}
pie_d <- tcr_lineageInfo %>% ungroup %>% 
    group_by(lineageType) %>%
    summarize(count = n()) %>%
    dplyr::mutate(
        labels = case_when(
            lineageType == "single" ~ "Cell in Singleton Lineages",
            lineageType == "multiple" ~ "Cell in Expanded Lineages"
        )
    )
total <- sum(pie_d$count)
pie_d <- pie_d %>%
    mutate(
        percentage = count/total,
        percentage = label_percent(0.01)(percentage)
    )

LineageCellNumber <- tcr_lineageInfo %>% 
    filter(lineageType == "multiple") %>%
    group_by(lineageName) %>%
    summarize(count = n()) %>%
    arrange(desc(count))

if(nrow(LineageCellNumber)>50){
    LineageCellNumber <- LineageCellNumber[1:50, ]
}

if(nrow(LineageCellNumber)>0){
    barplot_d <- tibble(rank=1:nrow(LineageCellNumber),
                        cellNum = LineageCellNumber$count)
}else{
    barplot_d <- tibble(rank=numeric(),
                        cellNum = numeric())
}

p1 <- ggplot(pie_d, aes(x = "", y = count, fill = labels))+geom_col(color = "black") +
    geom_text(aes(label = percentage),
                  position = position_stack(vjust = 0.5),
                  color = "white") +
    coord_polar(theta = "y")+
    scale_fill_manual(values = c("Cell in Expanded Lineages" = "#4169E1", "Cell in Singleton Lineages" = "grey"))+
    theme_void()+
    theme(legend.title = element_blank(), legend.position = "top", legend.direction = "vertical")

p2 <- ggplot(barplot_d, aes(x=rank, y = cellNum))+geom_bar(stat = "identity", fill = "#4169E1", color = "black")+
    xlab("Multi-cell Lineages") + ylab("Cell Count") +
    theme_classic()
p1+p2
```


`r if(!include_tcr) {"\\end{comment}"} else {NULL}`

`r if(!include_bcr) {"\\begin{comment}"} else {NULL}`

VDJ-B {data-orientation=rows}
====================

<h2 style="margin-top: 0.5rem; font-weight: bold;">Sample: `r params$sampleName` (VDJ-B)</h2>


```{r include=FALSE, eval = include_bcr}
vdj_b_cells <- read_tsv(params$VDJ_B_cells)
vdj_b_combinedInfo <- combineInfo(cells = vdj_b_cells$CB, 
                                  barcode_report = params$VDJ_B_report,
                                  airr_report = params$VDJ_B_airr)

vdj_b_cloneType <- vdj_b_combinedInfo %>%
    dplyr::select(chain1_cdr3aa, chain2_cdr3aa,
                  chain1_cdr3, chain2_cdr3,
                  chain1_V, chain1_D, chain1_J, 
                  chain2_V, chain2_J) %>%
    group_by(chain1_cdr3aa, chain2_cdr3aa, chain1_cdr3, chain2_cdr3, chain1_V, chain1_D, chain1_J, chain2_V, chain2_J) %>%
    summarize(cellCount = n()) %>%
    ungroup() %>%
    mutate(
        label1 = case_when(
            !is.na(chain1_V) ~ str_sub(chain1_V, 1L, 3L),
            !is.na(chain1_D) ~ str_sub(chain1_D, 1L, 3L),
            !is.na(chain1_J) ~ str_sub(chain1_J, 1L, 3L),
            TRUE ~ "Heavy"
        ),
        label2 = case_when(
            !is.na(chain2_V) ~ str_sub(chain2_V, 1L, 3L),
            !is.na(chain2_J) ~ str_sub(chain2_J, 1L, 3L),
            TRUE ~ "Light"
        ),
        Hchain_VDJ = paste0(chain1_V, "|", chain1_D, "|", chain1_J),
        Lchain_VDJ = paste0(chain2_V, "|", chain2_J)
    ) %>%
    mutate(
        cloneType = case_when(
            !is.na(chain1_cdr3aa) & !is.na(chain2_cdr3aa) ~ paste0(label1, ":", chain1_cdr3aa, ";", label2, ":", chain2_cdr3aa),
            is.na(chain1_cdr3aa) ~ paste0(label2, ":", chain2_cdr3aa),
            is.na(chain2_cdr3aa) ~ paste0(label1, ":", chain1_cdr3aa)
        )
    ) %>%
    arrange(desc(cellCount)) %>%
    mutate(Frequency = cellCount/nrow(vdj_b_combinedInfo)) %>%
    dplyr::select(cloneType, Hchain_VDJ, Lchain_VDJ, cellCount, Frequency)

vdj_b_cloneType$Hchain_VDJ[which(vdj_b_cloneType$Hchain_VDJ == "NA|NA|NA")] <- NA
vdj_b_cloneType$Lchain_VDJ[which(vdj_b_cloneType$Lchain_VDJ == "NA|NA")] <- NA
    
vdj_b_cloneType <- vdj_b_cloneType %>%
    mutate(
        id = 1:nrow(vdj_b_cloneType),
        Frequency = scales::label_percent(0.01)(Frequency)
    )
write_tsv(vdj_b_combinedInfo, file = paste0(params$sampleName, "_BCR_results.tsv"))
write_tsv(vdj_b_cloneType, file = paste0(params$sampleName, "_BCR_clonotypes.tsv"))
```

Row
----------

### Estimated Number of Cells


```{r include = FALSE, eval = include_bcr}
vdj_b_metrics <- fromJSON(params$VDJ_B_metrics)

```

```{r eval = include_bcr}
valueBox(vdj_b_metrics$cells %>% as.numeric() %>% label_comma()(), icon = "fa-circle-notch", color = "info")
```

### Mean VDJ Reads per Cell

```{r eval = include_bcr}
valueBox(vdj_b_metrics$meanVDJReadsPerCell %>% as.numeric() %>% round %>% label_comma()(), icon = "fa-chart-bar", color = "primary")
```

### Total Clonotypes Discovered

```{r eval = include_bcr}
valueBox(nrow(vdj_b_cloneType) %>% label_comma()(), icon = "fa-barcode", color = "warning")
```

Row
----------

### VDJ Stats `r infoIcon("VDJ_stats")`

```{r eval = include_bcr}
##Estimated Number of Cells
##Reads in Cells Mapped to Gene
##Fraction of Reads in Cells
##Mean Reads per Cell
##Median Reads per Cell
##UMIs in Cells
##Mean UMI per Cell
##Median UMI per Cell
##Mean Gene per Cell
##Median Gene per Cell

fractionAssembled <- as.numeric(vdj_b_metrics$totalReadsInCell)/(as.numeric(vdj_b_metrics$totalRawReads)*as.numeric(vdj_b_metrics$validBCreads))
fractionAssembled <- as.character(fractionAssembled)

vdj_b_tbl <- tribble(
  ~term, ~value,
  "Estimated Number of Cells (including non-pairing cells)", vdj_b_metrics$cells,
  "Reads in Cells Mapped to VDJ Gene", vdj_b_metrics$totalReadsInCell,
  "Fraction of Reads Used in Assembly", fractionAssembled,
  "Mean VDJ Reads per Cell", vdj_b_metrics$meanVDJReadsPerCell,
  "Median VDJ Reads per Cell", vdj_b_metrics$medianVDJReadsPerCell,
  "Mean Total UMIs per Cell", vdj_b_metrics$meanTotalUMIsPerCell,
  "Median Total UMIs per Cell", vdj_b_metrics$medianTotalUMIsPerCell,
  "Pairing Rate", vdj_b_metrics$pairingRate,
  "Total Clonotypes Detected", vdj_b_metrics$totalCloneTypes
) %>%
  mutate(value = as.numeric(value)) %>%
  mutate(value=case_when(value <= 1 ~ label_percent(0.01)(value),
                         value > 1 ~ label_comma()(round(value))))
## Rename UMI terms
if(!params$withUMI){
    vdj_b_tbl$term[which(vdj_b_tbl$term=="Mean Total UMIs per Cell")] <- "Mean Total Reads per Cell"
    vdj_b_tbl$term[which(vdj_b_tbl$term=="Median Total UMIs per Cell")] <- "Median Total Reads per Cell"
}

vdj_b_stats <- vdj_b_tbl

names(vdj_b_tbl) <- c("", "")
vdj_b_tbl %>% 
    kbl() %>% 
    kable_paper("hover", html_font = "arial, helvetica, sans-serif")
```

### Knee Plot `r infoIcon("VDJ_kneePlot")`

```{r eval = include_bcr}
cellNum <- as.numeric(vdj_b_metrics$cells)
vdj_b_kneeData <- read_tsv(params$VDJ_B_kneeOut, col_names = c("CB", "UMI"))
vdj_b_knee <- vdj_b_kneeData %>% 
    mutate(
        cell = c(1:nrow(vdj_b_kneeData)),
        group = case_when(
            CB %in% vdj_b_cells$CB ~ "cell",
            TRUE ~ "background"
        )
    )
fig <- plot_ly(data = vdj_b_knee, x = ~cell, y = ~UMI, type = 'scatter', mode = 'lines',
               color = ~group, colors = c('grey', '#002366'),
               hovertemplate = 'UMI: %{y}<extra>%{fullData.name}</extra>',
               line = list(width = 3),
               height = 400, width = 360)

fig <- layout(fig, xaxis = list(title = "Barcode Rank", type = "log"),yaxis = list(type = "log"), showlegend = FALSE)

if(!params$withUMI){
    fig <- layout(fig, yaxis = list(title = "Reads"))

}
config_plotly_fig(fig) %>% toWebGL()
```

Row {data-height=350}
----------

### Sequencing Stats `r infoIcon("Sequencing_stats")`

```{r eval = include_bcr}
##Number of Reads
##Reads With Valid Barcodes
##Sequencing Saturation
##Q30 Bases in CB+UMI
##Q30 Bases in RNA read
##Total VDJ Gene Fragments Detected

vdj_b_tbl <- tribble(
  ~term, ~value,
  "Number of Reads", vdj_b_metrics$totalRawReads,
  "Reads With Valid Barcodes", vdj_b_metrics$validBCreads,
  "Sequencing Saturation", vdj_b_metrics$saturation,
  "Q30 Bases in CB+UMI", vdj_b_metrics$q30InCBandUMI,
  "Q30 Bases in RNA read", vdj_b_metrics$q30InRNA
) %>%
  mutate(value = as.numeric(value)) %>%
  mutate(value=case_when(value <= 1 ~ label_percent(0.01)(value),
                         value > 1 ~ label_comma()(round(value))))

vdj_b_sequencing_stats <- vdj_b_tbl

names(vdj_b_tbl) <- c("", "")
vdj_b_tbl %>% 
    kbl() %>% 
    kable_paper("hover", html_font = "arial, helvetica, sans-serif")
```

### V(D)J Annotation `r infoIcon("BCR_annotation")`

```{r eval = include_bcr}
##Cells with productive V-J spanning pair
##Cells with productive V-J spanning (IGK, IGH) pair
##Cells with productive V-J spanning (IGL, IGH) pair
##Cells with productive IGH contig
##Cells with productive IGK contig
##Cells with productive IGL contig
##Paired clonotype diversity
medianUMIsChain1 <- vdj_b_combinedInfo$chain1_expr %>% median(na.rm = TRUE) %>% as.numeric()
medianUMIsChain2 <- vdj_b_combinedInfo$chain2_expr %>% median(na.rm = TRUE) %>% as.numeric()
cellsWithProductiveChainIGH <- vdj_b_combinedInfo %>%
    filter(chain1_productive, chain1_type == "IGH") %>% nrow() %>% as.numeric()
cellsWithProductiveChainIGK <- vdj_b_combinedInfo %>%
    filter(chain2_productive, chain2_type == "IGK") %>% nrow() %>% as.numeric()
cellsWithProductiveChainIGL <- vdj_b_combinedInfo %>%
    filter(chain2_productive, chain2_type == "IGL") %>% nrow() %>% as.numeric()
cellsWithProductiveChainIGKIGH <- vdj_b_combinedInfo %>%
    filter(chain1_productive,
           chain2_productive, 
           chain1_type == "IGH", 
           chain2_type == "IGK") %>% 
    nrow() %>% as.numeric()
cellsWithProductiveChainIGLIGH <- vdj_b_combinedInfo %>%
    filter(chain1_productive, 
           chain2_productive, 
           chain1_type == "IGH", 
           chain2_type == "IGL") %>% 
    nrow() %>% as.numeric()

vdj_b_tbl <- tribble(
  ~term, ~value,
  "Median IGH UMIs per Cell", medianUMIsChain1,
  "Median IGK/L UMIs per Cell", medianUMIsChain2,
  "Cells with Productive IGH", cellsWithProductiveChainIGH,
  "Cells with Productive IGK", cellsWithProductiveChainIGK,
  "Cells with Productive IGL", cellsWithProductiveChainIGL,
  "Cells with Productive IGKIGH pair", cellsWithProductiveChainIGKIGH,
  "Cells with Productive IGLIGH pair", cellsWithProductiveChainIGLIGH
) %>%
  mutate(value = as.numeric(value)) %>%
  mutate(value = label_comma()(round(value)))

vdj_b_annotation <- vdj_b_tbl

names(vdj_b_tbl) <- c("", "")
vdj_b_tbl %>% 
    kbl() %>% 
    kable_paper("hover", html_font = "arial, helvetica, sans-serif")
```

Row
----------

### GEX Association `r infoIcon("gexAssociation")`

```{r eval = (include_bcr & include_gex)}
## Only plot cluster when there are more than 150 filtered cells
if(filtered_cells >= 150){
    ##clusterPlot <- DimPlot(object=seuratData, reduction="umap", label=TRUE, repel=TRUE)
    bcr_cdrSeq <- read_tsv(params$VDJ_B_report) %>%
        select(`#barcode`, `chain1`, `chain2`)
    bcr_cdrSeq$chain1_cdr3 <- ""
    bcr_cdrSeq$chain2_cdr3 <- ""
    for(i in 1:nrow(bcr_cdrSeq)){
        bcr_cdrSeq$chain1_cdr3[i] <- unlist(strsplit(bcr_cdrSeq$chain1[i], ","))[6]
        bcr_cdrSeq$chain2_cdr3[i] <- unlist(strsplit(bcr_cdrSeq$chain2[i], ","))[6]
    }
    ## extract data from seuratData
    bcr_cells <- vdj_b_knee %>%
        filter(group == "cell") %>%
        pull(CB)
    bcr_data <- vdj_b_kneeData %>%
        filter(CB %in% bcr_cells) %>%
        left_join(bcr_cdrSeq, by = c("CB" = "#barcode"))
    clusterData2 <- clusterData %>% left_join(bcr_data, by = c("bc" = "CB")) %>%
        dplyr::select(bc, UMAP_1, UMAP_2, chain1_cdr3, chain2_cdr3) %>%
        dplyr::mutate(
            text = paste0(chain1_cdr3, "+", chain2_cdr3),
            type = case_when(
                !is.na(chain1_cdr3) & !is.na(chain2_cdr3) ~ "Detected",
                TRUE ~ "Not captured"
            )
        )

    plot_ly(clusterData2, x = ~UMAP_1, y= ~UMAP_2, color = ~type, 
            text = ~text,
            type = 'scatter', mode = 'markers',
            marker = list(opacity = 0.5),
            colors = c("#9370DB", "grey"),
            hovertemplate = 'CDR3: %{text}<extra><b>Type: %{fullData.name}</b></extra>') %>%
        config_plotly_fig() %>%
        toWebGL()
    
    ##clusterPlot %>% ggplotly() %>%
    ##    config(displaylogo = FALSE,
    ##           modeBarButtonsToRemove = c('zoom', 'pan', 'select', 'zoomIn', 'zoomOut', 'autoScale',
    ##                                      'hoverClosestCartesian', 'hoverCompareCartesian')) %>% toWebGL()
}else{
    cat("Too few cells: ", filtered_cells, "(filtered by nFeature >= 200)\n")
}
```

```{r eval = !(include_bcr & include_gex)}
cat("No gene expression library\n")
```

### Top 10 Clonotypes `r infoIcon("Clonetypes_top10")`

```{r eval = include_bcr}
fig <- plot_ly(data = vdj_b_cloneType %>% filter(id<=10), x = ~id, y = ~cellCount, type = "bar")
fig <- layout(fig, showlegend = FALSE)
config_plotly_fig(fig)
```

Row {style="margin-right: 8px"}
----------

### Identified Clonotypes (top 1000) `r infoIcon("Clonetypes_top1000")` {style="width: 100% !important"}

```{r eval = include_bcr}
vdj_b_cloneType %>%
    filter(id <= 1000) %>%
    DT::datatable(rownames = FALSE, width = "100%",
                  options = list(scrollX = T, scrollY = F, pageLength = 10))
```

Row {data-height=400}
----------

### V Region Coverage (Chain1) `r infoIcon("Chain_coverage")`

```{r eval = include_bcr, fig.width = 7, fig.height = 4}
coverage_plots <- plot_VDJ_coverage(
    cells = vdj_b_cells$CB, 
    barcode_report = params$VDJ_B_report, 
    airr_report = params$VDJ_B_airr, 
    trust4_final_out = params$VDJ_B_finalOut, 
    type = "VDJ-B"
)
coverage_plots$chain1_plot
```

### V Region Coverage (Chain2) `r infoIcon("Chain_coverage")`


```{r eval = include_bcr, fig.width = 7, fig.height = 4}
coverage_plots$chain2_plot
```

Row {data-height=400}
----------

### Lineage & Clonotype Stats `r infoIcon("Lineage_annotation")`

```{r eval = include_bcr}
bcr_lineageInfo <- getLineage(cells = vdj_b_cells$CB,
                              barcode_report = params$VDJ_B_report,
                              airr_report = params$VDJ_B_airr)

write_tsv(bcr_lineageInfo, file = paste0(params$sampleName, "_BCR_results.productiveOnly_withLineage.tsv"))

bcr_pairing_clones <- bcr_lineageInfo %>%
    select(chain1_V, chain1_D, chain1_J, chain1_cdr3,
           chain2_V, chain2_J, chain2_cdr3) %>%
    na.omit() %>%
    distinct() %>%
    nrow()
bcr_lineage_number <- bcr_lineageInfo %>%
    pull(lineageName) %>%
    unique() %>% length()
multipleLineageCellNumber <- bcr_lineageInfo %>%
    filter(lineageType == "multiple") %>%
    nrow()
multipleCellLineageNumber <- bcr_lineageInfo %>%
    filter(lineageType == "multiple") %>%
    pull(lineageName) %>%
    unique() %>% length()
singleCellLineageNumber <- bcr_lineageInfo %>%
    filter(lineageType == "single") %>%
    pull(lineageName) %>%
    unique() %>% length()

pairingAccuracy <- calc_pairing_accuracy(bcr_lineageInfo)
entropy <- getEntropy(bcr_lineageInfo)
clonality <- getClonality(entropy, bcr_pairing_clones)


lineage_tbl <- tribble(
    ~term, ~value,
    "Clones (Paired)", label_comma()(bcr_pairing_clones),
    "Lineage Number", label_comma()(bcr_lineage_number),
    "Single Cell Lineage Number", label_comma()(singleCellLineageNumber),
    "Multiple Cell Lineage Number", label_comma()(multipleCellLineageNumber),
    "Cells in Multiple Cell Lineages", label_comma()(multipleLineageCellNumber),
    "Total Cells with Paired Clones", label_comma()(nrow(bcr_lineageInfo)),
    "Pairing Accuracy", label_percent(0.01)(pairingAccuracy),
    "Shannon Entropy", label_number(0.001)(entropy),
    "Clonality", label_number(0.001)(clonality)
)

vdj_b_metrics_final <- bind_rows(
    vdj_b_stats,
    vdj_b_sequencing_stats,
    vdj_b_annotation,
    lineage_tbl
)

write_tsv(vdj_b_metrics_final,
          paste0(params$sampleName, "_VDJ-B.metrics.tsv"), 
          col_names=FALSE)

vdj_b_metrics_final %>%
    split(vdj_b_metrics_final$term) %>% 
    lapply(FUN=function(x) { x$value }) %>% 
    write_json(paste0(params$sampleName, "_VDJ-B.metrics.json"), pretty = TRUE, auto_unbox = TRUE)

names(lineage_tbl) <- c("", "")
lineage_tbl %>% 
    kbl() %>% 
    kable_paper("hover", html_font = "arial, helvetica, sans-serif")
```

### Lineage Plots `r infoIcon("Lineage_plot")`


```{r eval = include_bcr, fig.width = 7, fig.height=3.5}
pie_d <- bcr_lineageInfo %>% ungroup %>% 
    group_by(lineageType) %>%
    summarize(count = n()) %>%
    dplyr::mutate(
        labels = case_when(
            lineageType == "single" ~ "Cell in Singleton Lineages",
            lineageType == "multiple" ~ "Cell in Expanded Lineages"
        )
    )
total <- sum(pie_d$count)
pie_d <- pie_d %>%
    mutate(
        percentage = count/total,
        percentage = label_percent(0.01)(percentage)
    )

LineageCellNumber <- bcr_lineageInfo %>% 
    filter(lineageType == "multiple") %>%
    group_by(lineageName) %>%
    summarize(count = n()) %>%
    arrange(desc(count))

if(nrow(LineageCellNumber)>50){
    LineageCellNumber <- LineageCellNumber[1:50, ]
}

if(nrow(LineageCellNumber)>0){
    barplot_d <- tibble(rank=1:nrow(LineageCellNumber),
                        cellNum = LineageCellNumber$count)
}else{
    barplot_d <- tibble(rank=numeric(),
                        cellNum = numeric())
}

p1 <- ggplot(pie_d, aes(x = "", y = count, fill = labels))+geom_col(color = "black") +
    geom_text(aes(label = percentage),
                  position = position_stack(vjust = 0.5),
                  color = "white") +
    coord_polar(theta = "y")+
    scale_fill_manual(values = c("Cell in Expanded Lineages" = "#4169E1", "Cell in Singleton Lineages" = "grey"))+
    theme_void()+
    theme(legend.title = element_blank(), legend.position = "top", legend.direction = "vertical")

p2 <- ggplot(barplot_d, aes(x=rank, y = cellNum))+geom_bar(stat = "identity", fill = "#4169E1", color = "black")+
    xlab("Multi-cell Lineages") + ylab("Cell Count") +
    theme_classic()
p1+p2
```


`r if(!include_bcr) {"\\end{comment}"} else {NULL}`

Running Info {data-orientation=rows}
====================

Row {data-height=600}
----------

### Running Information

```{r}
version_info <- fromJSON(params$version_json)

if(include_gex){
    cellCallingMethod <- version_info$soloCellFilter
}else{
    cellCallingMethod <- "cellRanger 2.2"
}
version_tbl <- tribble(
  ~term, ~value,
  "Sample ID", params$sampleName,
  "Pipeline Version", version_info$pipeline_version,
  "Reference Dir", version_info$referenceDir,
  "Reference GTF", version_info$referenceGTF,
  "Whitelist", version_info$whitelist,
  "VDJ Assembled with Only cDNA Reads", version_info$assembleWithcDNAreadOnly,
  "STAR Version", version_info$STAR_version,
  "Whitelist Matching", version_info$soloCBmatchWLtype,
  "UMIfiltering", version_info$soloUMIfiltering,
  "UMIdedup", version_info$soloUMIdedup,
  "Cell Calling", cellCallingMethod,
  "includeIntron", version_info$includeIntron,
  "includeMultiReads", version_info$includeMultiReads
)
if(!params$withUMI){
    version_tbl <- version_tbl %>%
        filter(!(term %in%c("UMIfiltering", "UMIdedup")))
}
if(!include_gex){
    version_tbl <- version_tbl %>%
        filter(!(term %in%c("includeIntron", "includeMultiReads")))
}
names(version_tbl) <- c("", "")
version_tbl %>% 
    kbl() %>% 
    kable_paper("hover", html_font = "arial, helvetica, sans-serif")
```

```{js}
// set knee plot margin to auto
$( document ).ready(function() {
    document.querySelectorAll("div.plot-container > div.svg-container").forEach(el => el.style.margin = "auto");
});
```