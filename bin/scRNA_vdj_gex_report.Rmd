---
title: "ThunderBio VDJ Report"
date: "`r Sys.Date()`"
output: 
  flexdashboard::flex_dashboard:
    vertical_layout: scroll
    orientation: rows
    theme: 
      bootswatch: flatly
      version: 5
      bslib: true
      base_font:
        google: Asap
params:
  sampleName : "sampleName"
  featureStats: "sampleID.featureCoverage_stats.json"
  geneCoverage: "sampleID.scaled.tab"
  starsolo_matrixDir: "sample/Gene/filtered"
  starsolo_out : "Summary.csv"
  starsolo_bc : "UMIperCellSorted.txt"
  saturation_json: "saturation_out.json"
  version_json: "versions.json"
  nCPUs: 10
  nMem: 10000000000.0
  nFeature_RNA_lower: 200
  percent_mt_cutoff: 100
  pca_dim: 30
  resolution: 0.8
  VDJ_B_report: "VDJ_B_report.tsv"
  VDJ_B_airr: "VDJ_B_airr.tsv"
  VDJ_B_kneeOut: "VDJ_B_kneeOut.tsv"
  VDJ_B_finalOut: "VDJ_B_finalOut.tsv"
  VDJ_B_cells: "VDJ_B_cells.tsv"
  VDJ_B_metrics: "VDJ-B_metrics.json"
  VDJ_B_cloneType : "VDJ-B.cloneType.tsv"
  VDJ_T_report: "VDJ_T_report.tsv"
  VDJ_T_airr: "VDJ_T_airr.tsv"
  VDJ_T_kneeOut: "VDJ_T_kneeOut.tsv"
  VDJ_T_finalOut: "VDJ_T_finalOut.tsv"
  VDJ_T_cells: "VDJ_T_cells.tsv"
  VDJ_T_metrics: "VDJ-T_metrics.json"
  VDJ_T_cloneType: "VDJ-T.cloneType.tsv"
  withUMI: TRUE
---

```{css echo = FALSE}
.chart-title {
  font-size: 1.2rem;
  font-weight: 700;
  margin-left: 10px;
  margin-right: 10px;
}
```

```{js echo = FALSE}
// shrink navbar height
document.querySelector(".navbar").classList.add("pt-1")
document.querySelector(".navbar").classList.add("pb-1")
```

```{r include=FALSE}
library(tidyverse)
library(scales)
library(flexdashboard)
library(jsonlite)
library(DT)
##library(htmlwidgets)
library(plotly)
library(kableExtra)
library(Seurat)
library(future)
##library(VennDiagram)
library(Biostrings)
library(data.table)
library(matrixStats)
library(reshape2)
library(ComplexHeatmap)
library(seqinr)
library(stringi)
library(patchwork)
library(htmltools)

set.seed(1234)
plan("multicore", workers = as.numeric(params$nCPUs))
options(future.globals.maxSize = as.numeric(params$nMem), sass.cache = FALSE)
RhpcBLASctl::blas_set_num_threads(1) # https://github.com/satijalab/seurat/issues/3991

## Rmd options
knitr::opts_chunk$set(
  comment = '', fig.retina = 4,
  warning = FALSE, message = FALSE
)


config_plotly_fig <- function(fig, ...){
    config(
        fig,
        displaylogo = FALSE, 
        modeBarButtonsToRemove = c('zoom', 'pan', 'select', 'zoomIn', 'zoomOut', 'autoScale',
                                   'hoverClosestCartesian', 'hoverCompareCartesian'),
        toImageButtonOptions = list(height= NULL, width= NULL, scale= 2),
        ...
    )
}

## Set kableExtra font here
html_font <- "Asap, Arial, sans-serif"

## decide whether to incldue each page
## conditional page solution is from: https://stackoverflow.com/questions/59202693/how-can-i-create-a-conditional-flexdashboard-layout
if(is.null(params$starsolo_matrixDir) || params$starsolo_matrixDir == "") {
    include_gex <- FALSE
}else{
    include_gex <- TRUE
}
if(is.null(params$VDJ_T_metrics) || params$VDJ_T_metrics == "") {
    include_tcr <- FALSE
}else{
    include_tcr <- TRUE
}
if(is.null(params$VDJ_B_metrics) || params$VDJ_B_metrics == "") {
    include_bcr <- FALSE
}else{
    include_bcr <- TRUE
}


## Note since GEX data only support UMI, so include_gex requires withUMI == TRUE
if(include_gex && !params$withUMI){
    stop("GEX data requires library structure containing UMI")
}
```


```{r infoIcon, include = FALSE}
infoIcon <- function(targetEl, size = "1.2rem"){
  querySelector <- paste0("#", targetEl)
  ## Make HTML
  questionIconString <- paste0(
      '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" class="bi bi-question-circle-fill " style="height:',
      size,
      ';width:',
      size,
      ';fill:currentColor;vertical-align:-0.125em;fill:var(--bs-primary);" aria-hidden="true" role="img"><path d="M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0zM5.496 6.033h.825c.138 0 .248-.113.266-.25.09-.656.54-1.134 1.342-1.134.686 0 1.314.343 1.314 1.168 0 .635-.374.927-.965 1.371-.673.489-1.206 1.06-1.168 1.987l.003.217a.25.25 0 0 0 .25.246h.811a.25.25 0 0 0 .25-.25v-.105c0-.718.273-.927 1.01-1.486.609-.463 1.244-.977 1.244-2.056 0-1.511-1.276-2.241-2.673-2.241-1.267 0-2.655.59-2.75 2.286a.237.237 0 0 0 .241.247zm2.325 6.443c.61 0 1.029-.394 1.029-.927 0-.552-.42-.94-1.029-.94-.584 0-1.009.388-1.009.94 0 .533.425.927 1.01.927z"></path></svg>'
  )
  outTag <- tags$i(
      HTML(questionIconString),
      `data-bs-toggle`="modal",
      `data-bs-target`=querySelector
  )
  return(outTag)
}

createModal <- function(Id, expl_tbl){
    contentTag <- expl_tbl %>%
        apply(1, FUN=function(x){
            tagList(
                h6(HTML(x[1]), style="font-weight:700;"),
                p(HTML(x[2]))
            )
        }) %>% 
        tagList()

   outTag <- div(
       class = "modal fade",
       id = Id,
       tabindex = -1,
       `aria-labelledby`="exampleModalLabel",
       `aria-hidden`="true",
       div(
           class = "modal-dialog modal-dialog-centered modal-dialog-scrollable modal-lg",
           div(
               class = "modal-content",
               div(
                   class = "modal-body",
                   div(
                       class = "explanation",
                       contentTag
                   )
               )
           )
       )
   )
   return(outTag)
}
```

```{css}
.explanation {
  background-color: rgba(var(--bs-secondary-rgb), 0.2); 
  border-radius: var(--bs-modal-border-radius);
  padding: 1rem
}
```


```{r include = FALSE}
## Combine TCR/BCR information from barcode_report and airr_report
combineInfo <- function(cells, barcode_report, airr_report){
    d <- read_tsv(barcode_report) %>%
        dplyr::rename("barcode" = "#barcode") %>%
        select(barcode, chain1, chain2, secondary_chain1, secondary_chain2) %>% 
        filter(barcode %in% cells)
    
    d$chain1_contig <- strsplit(d$chain1,",") %>% sapply("[", 8)
    d$chain2_contig <- strsplit(d$chain2,",") %>% sapply("[", 8)
    
    d$chain1_V <- strsplit(d$chain1,",") %>% sapply("[",1) %>% str_remove("\\*[0-9]+$")
    d$chain1_D <- strsplit(d$chain1,",") %>% sapply("[",2) %>% str_remove("\\*[0-9]+$")
    d$chain1_J <- strsplit(d$chain1,",") %>% sapply("[",3) %>% str_remove("\\*[0-9]+$")
    d$chain1_cdr3 <- strsplit(d$chain1,",") %>% sapply("[",5)
    
    d$chain2_V <- strsplit(d$chain2,",") %>% sapply("[",1) %>% str_remove("\\*[0-9]+$")
    d$chain2_D <- strsplit(d$chain2,",") %>% sapply("[",2) %>% str_remove("\\*[0-9]+$")
    d$chain2_J <- strsplit(d$chain2,",") %>% sapply("[",3) %>% str_remove("\\*[0-9]+$")
    d$chain2_cdr3 <- strsplit(d$chain2,",") %>% sapply("[",5)
    
    airr <- read_tsv(airr_report) %>%
        select(sequence_id, sequence, cdr1, cdr2, complete_vdj, productive)
    
    d <- d %>% 
        left_join(airr, by = c("chain1_contig" = "sequence_id")) %>%
        dplyr::rename(
            "chain1_contigSeq" = "sequence",
            "chain1_cdr1" = "cdr1",
            "chain1_cdr2" = "cdr2",
            "chain1_complete" = "complete_vdj",
            "chain1_productive" = "productive"
        ) %>%
        left_join(airr, by = c("chain2_contig" = "sequence_id")) %>%
        dplyr::rename(
            "chain2_contigSeq" = "sequence",
            "chain2_cdr1" = "cdr1",
            "chain2_cdr2" = "cdr2",
            "chain2_complete" = "complete_vdj",
            "chain2_productive" = "productive"
        )
    d$chain1_cdr3aa <- strsplit(d$chain1, ",") %>% sapply("[", 6)
    d$chain2_cdr3aa <- strsplit(d$chain2, ",") %>% sapply("[", 6)
    d$chain1_expr <- strsplit(d$chain1, ",") %>% sapply("[", 7) %>% as.numeric()
    d$chain2_expr <- strsplit(d$chain2, ",") %>% sapply("[", 7) %>% as.numeric()
    d <- d %>%
        mutate(
            chain1_type = case_when(
                str_detect(chain1_V, "IGH") ~ "IGH",
                str_detect(chain1_D, "IGH") ~ "IGH",
                str_detect(chain1_J, "IGH") ~ "IGH",
                str_detect(chain1_V, "TRB") ~ "TRB",
                str_detect(chain1_D, "TRB") ~ "TRB",
                str_detect(chain1_J, "TRB") ~ "TRB",
                str_detect(chain1_V, "TRD") ~ "TRD",
                str_detect(chain1_D, "TRD") ~ "TRD",
                str_detect(chain1_J, "TRD") ~ "TRD",
                TRUE ~ "unknown"
            ),
            chain2_type = case_when(
                str_detect(chain2_V, "IGK") ~ "IGK",
                str_detect(chain2_J, "IGK") ~ "IGK",
                str_detect(chain2_V, "IGL") ~ "IGL",
                str_detect(chain2_J, "IGL") ~ "IGL",
                str_detect(chain2_V, "TRA") ~ "TRA",
                str_detect(chain2_J, "TRA") ~ "TRA",
                str_detect(chain2_V, "TRG") ~ "TRG",
                str_detect(chain2_J, "TRG") ~ "TRG",
                TRUE ~ "unknown"
            )
        )
    d <- d %>% dplyr::select(-c(chain1, chain2))
    ## relocate columns
    d <- d %>% 
        dplyr::select(barcode, 
                      chain1_V, chain1_D, chain1_J, chain1_cdr1, chain1_cdr2, chain1_cdr3, chain1_cdr3aa, 
                      chain1_complete, chain1_productive, chain1_type, chain1_expr, chain1_contig, chain1_contigSeq, secondary_chain1,
                      chain2_V, chain2_D, chain2_J, chain2_cdr1, chain2_cdr2, chain2_cdr3, chain2_cdr3aa, 
                      chain2_complete, chain2_productive, chain2_type, chain2_expr, chain2_contig, chain2_contigSeq, secondary_chain2) %>%
        mutate(across(c(starts_with("chain"), starts_with("secondary")), 
                      .fns = function(x) ifelse(x != "*", x, NA)))
    return(d)
}
## Lineage stats
## Get lineage information, only using cells with paired and productive chains
## Lineage defined as the same VDJ segments, identical CDR3 nucleotides length and > 80% CDR3 nt
getLineage <- function(cells, barcode_report, airr_report){
    
    d <- combineInfo(cells, barcode_report, airr_report)
    
    ## filter d to only retain the cells with the productive chains
    d0 <- d %>%
        filter(!is.na(chain1_contig), !is.na(chain2_contig)) %>%
        filter(chain1_productive == TRUE, chain2_productive == TRUE) %>%
        mutate(cdrh3_len = str_length(chain1_cdr3)) %>%
        group_by(chain1_V, chain1_D, chain1_J, chain2_V, chain2_D, chain2_J, cdrh3_len) %>% 
        group_split()
    
    d_single <- d0[sapply(d0, nrow)==1]
    d_multiple <- d0[sapply(d0, nrow)>1]
    
    d_multiple_final <- list()
    if(length(d_multiple)>0){
        for(i in 1:length(d_multiple)){
            
            k <- d_multiple[[i]] %>% pull(chain1_cdr3)
            aln <- as.alignment(nb = length(k), nam = 1:length(k), k)
            aln_dist <- dist.alignment(aln, matrix = "identity",gap = T) %>% as.matrix()
            identityM <- 1-aln_dist^2
            
            tr <- hclust(as.dist(1-identityM))
            ## use cutree to define families, cutoff is 0.2 (80% identity)
            familyIdx <- cutree(tr, h=0.2)
            
            if(length(unique(familyIdx))==1){
                d_multiple_final[[length(d_multiple_final)+1]] <- d_multiple[[i]]
            }else{
                m <- d_multiple[[i]] %>%
                    mutate(family=as.character(familyIdx)) %>%
                    ungroup() %>%
                    group_by(family) %>%
                    group_split(.keep = FALSE)
                for(u in 1:length(m)){
                    if(nrow(m[[u]])>1){
                        d_multiple_final[[length(d_multiple_final)+1]] <- m[[u]]
                    }else{
                        d_single[[length(d_single)+1]] <- m[[u]]
                    }
                }
            }
        }
    }
    
    singleInfo <- list()
    if(length(d_single)>0){
        for(i in 1:length(d_single)){
            singleInfo[[i]] <- d_single[[i]] %>%
                mutate(lineageType = "single",
                       lineageName = paste0("LS", i))
        }
    }
    multipleInfo <- list()
    if(length(d_multiple_final)>0){
        for(i in 1:length(d_multiple_final)){
            multipleInfo[[i]] <- d_multiple_final[[i]] %>%
                mutate(lineageType = "multiple",
                       lineageName = paste0("LM", i))
        }
    }
    single_df <- do.call(bind_rows, singleInfo)
    multiple_df <- do.call(bind_rows, multipleInfo)
    lineageInfo <- bind_rows(single_df, multiple_df)
    return(ungroup(lineageInfo))
}
```


```{r include = FALSE}
## pairing accuracy
## Defined as cells with identical H chain VDJ as well as CHRH3 but different L chain VDJ
## take lineageInfo data (getLineage() output) as input

calc_pairing_accuracy <- function(lineageInfo){
    totalCells <- nrow(lineageInfo)
    d <- lineageInfo %>% ungroup() %>%
        group_by(chain1_V, chain1_D, chain1_J, chain1_cdr3) %>%
        group_split()
    disconcordantCells <- d %>% sapply(FUN = function(x){
        x %>% select(chain2_V, chain2_J) %>%
            ungroup() %>%
            group_by(chain2_V, chain2_J) %>%
            summarize(count = n()) %>% 
            arrange(desc(count)) %>%
            slice_tail(n=-1) %>%
            pull(count) %>%
            sum()
    }) %>%
    sum()
    return(1-disconcordantCells/totalCells)
}
```


```{r include = FALSE}
## https://liulab-dfci.github.io/RIMA/Repertoire.html#tcr-and-bcr-entropy-and-clonality
## function to calculate Shannon entropy and clonality
## take lineageInfo data (getLineage() output) as input

getEntropy <- function(lineageInfo){
    totalCells <- nrow(lineageInfo)
    ## use cloneType instead of family
    d <- lineageInfo %>% 
        ungroup() %>%
        group_by(chain1_V, chain1_D, chain1_J, chain1_cdr3, chain2_V, chain2_J, chain2_cdr3) %>%
        summarize(cellCount = n()) %>%
        mutate(percent = cellCount/totalCells) %>%
        pull(percent)
    entropy <- -sum(log(d)*d)
}

getClonality <- function(entropy, cloneTypeNum){
    1-(entropy/log(cloneTypeNum))
}
```


```{r include = FALSE}
## VDJ coverage function
## contributed by Yuanzhen (yuanzhen@thunder-bio.com)
plot_VDJ_coverage <- function(cells, barcode_report, airr_report, trust4_final_out, type = "VDJ-B"){
  
  cell_report <- read_delim(barcode_report,
                            delim = "\t", escape_double = FALSE,
                            trim_ws = TRUE) %>% 
    dplyr::rename(barcode=`#barcode`) %>%
    filter(barcode %in% cells)
  d <- cell_report %>% select(barcode, chain1, chain2)
  d$chain1_contig <- strsplit(d$chain1,",") %>% sapply("[", 8)
  d$chain2_contig <- strsplit(d$chain2,",") %>% sapply("[", 8)
  airr <- read_delim(airr_report, 
                     delim = "\t", escape_double = FALSE,
                     trim_ws = TRUE)
  
  VDJ_final_matrix=fread(trust4_final_out,
                         sep="",
                         header = F)
  
  name_fi_=VDJ_final_matrix$V1 %>% str_remove_all(">") %>% str_remove_all("\\s[A-Z]+.*")
  
  chain1_info <- airr %>% select(sequence_id, sequence, junction, cdr1, cdr2) %>% 
    filter(sequence_id %in% na.omit(d$chain1_contig)) %>% filter(str_length(junction)>4)
  chain2_info <- airr %>% select(sequence_id, sequence, junction, cdr1, cdr2) %>% 
    filter(sequence_id %in% na.omit(d$chain2_contig)) %>% filter(str_length(junction)>4)
  
  if(type == "VDJ-B"){
    p1 <- .vh_vl_plot(vdj_type = "BCR_VH", chainInfo = chain1_info, name_fi = name_fi_)
    p2 <- .vh_vl_plot(vdj_type = "BCR_VL", chainInfo = chain2_info, name_fi = name_fi_)
  }else if(type == "VDJ-T"){
    p1 <- .vh_vl_plot(vdj_type = "TCR_VH", chainInfo = chain1_info, name_fi = name_fi_)
    p2 <- .vh_vl_plot(vdj_type = "TCR_VL", chainInfo = chain2_info, name_fi = name_fi_)
  }
  
  plotList <- list(chain1_plot = p1, chain2_plot = p2)
  
  return(plotList)
}


extract_cdr_start <- function(vdj_seq, cdr_seq){
    stri_locate_last(vdj_seq, regex = cdr_seq)[1]
}

extract_cdr_end <- function(vdj_seq, cdr_seq){
    stri_locate_last(vdj_seq, regex = cdr_seq)[2]
}

.vh_vl_plot=function(vdj_type, chainInfo, name_fi){
  
  chainInfo=chainInfo[!is.na(chainInfo$junction), ]
  ## Remove cells with too short cdr3 (4nt)
  chainInfo <- chainInfo %>%
      filter(str_length(junction)>4)
  
  if(nrow(chainInfo)==0){
    stop("your VDJ do not complete(not have cdr3 at least)")
  }
  
  ## generate cdr start and end
  chainInfo$cdr1_start <- map2_int(chainInfo$sequence, chainInfo$cdr1, .f = extract_cdr_start)
  chainInfo$cdr1_end <- map2_int(chainInfo$sequence, chainInfo$cdr1, .f = extract_cdr_end)
  chainInfo$cdr2_start <- map2_int(chainInfo$sequence, chainInfo$cdr2, .f = extract_cdr_start)
  chainInfo$cdr2_end <- map2_int(chainInfo$sequence, chainInfo$cdr2, .f = extract_cdr_end)
  chainInfo$cdr3_start <- map2_int(chainInfo$sequence, chainInfo$junction, .f = extract_cdr_start)
  chainInfo$cdr3_end <- map2_int(chainInfo$sequence, chainInfo$junction, .f = extract_cdr_end)
  
  chain_locate=match(chainInfo$sequence_id, name_fi)
  
  
  #B cell  IMGT numbering
  #
  #IGHV
  #cdr1:27-38
  #cdr2:56-65
  #cdr3:105-115
  #
  #IGKV
  #cdr1:27-38
  #cdr2:56-65
  #cdr3:105-1100
  #
  #
  #IGLV
  #cdr1:27-38
  #cdr2:56-65
  #cdr3:105-115
  #
  #
  # more information about B cell numberiing https://www.imgt.org/IMGTScientificChart/Numbering/IMGT-Kabat_part1.html
  #
  #T cell IMGT numbering
  #
  #TRBV
  #cdr1:27-38
  #cdr2:56-65
  #cdr3:105-109
  #
  #
  #TRAV
  #cdr1:27-38
  #cdr2:56-65
  #cdr3:105-107
  #
  #TRDV
  #cdr1:27-38
  #cdr2:56-65
  #cdr3:105-108
  #
  #
  #TRGV
  #cdr1:27-38
  #cdr2:56-65
  #cdr3:105-109
  #
  #
  #more information about T cell numberiing:https://www.imgt.org/IMGTScientificChart/Numbering/IMGT-Kabat_part2.html
  #
  if(vdj_type=="BCR_VH"){
    cdr1_start=27
    cdr1_end=38
    cdr2_start=56
    cdr2_end=65
    cdr3_start=105
    cdr3_end=115
  }else if(vdj_type=="BCR_VL"){
    cdr1_start=27
    cdr1_end=38
    cdr2_start=56
    cdr2_end=65
    cdr3_start=105
    cdr3_end=115
  }else if(vdj_type=="TCR_VH"){
    ## used TRB location as representative
    cdr1_start=27
    cdr1_end=38
    cdr2_start=56
    cdr2_end=65
    cdr3_start=105
    cdr3_end=109
  }else if(vdj_type=="TCR_VL"){
    ## used TRA location as representative
    cdr1_start=27
    cdr1_end=38
    cdr2_start=56
    cdr2_end=65
    cdr3_start=105
    cdr3_end=109
  }else{
    errorCondition("your vdj_type not correctly, please use VH or VL")
  }
  
  ## Align sequences
  convert_position <- function(imgt_cdr3_aa_start, cdr3_start, seq_position){
      return(seq_position + as.integer(imgt_cdr3_aa_start) * 3L - cdr3_start)
  }
  
  ## Do not use pmap_int() here!
  ## Note 3L above
  chainInfo$cdr1_start_aligned <- pmap_dbl(list(cdr3_start, chainInfo$cdr3_start, chainInfo$cdr1_start), .f = convert_position)
  chainInfo$cdr1_end_aligned <- pmap_dbl(list(cdr3_start, chainInfo$cdr3_start, chainInfo$cdr1_end), .f = convert_position)
  chainInfo$cdr2_start_aligned <- pmap_dbl(list(cdr3_start, chainInfo$cdr3_start, chainInfo$cdr2_start), .f = convert_position)
  chainInfo$cdr2_end_aligned <- pmap_dbl(list(cdr3_start, chainInfo$cdr3_start, chainInfo$cdr2_end), .f = convert_position)
  chainInfo$cdr3_start_aligned <- pmap_dbl(list(cdr3_start, chainInfo$cdr3_start, chainInfo$cdr3_start), .f = convert_position)
  chainInfo$cdr3_end_aligned <- pmap_dbl(list(cdr3_start, chainInfo$cdr3_start, chainInfo$cdr3_end), .f = convert_position)
  chainInfo$seq_start_aligned <- pmap_dbl(list(cdr3_start, chainInfo$cdr3_start, rep(1, nrow(chainInfo))), .f = convert_position)
  chainInfo$seq_end_aligned <- pmap_dbl(list(cdr3_start, chainInfo$cdr3_start, str_length(chainInfo$sequence)), .f = convert_position)

  chain_count <- lapply(1:length(chain_locate), function(i){
    nt_1_weight <- name_fi[chain_locate[i]+2] %>% str_split(" ") %>% unlist() %>% as.numeric()
    nt_2_weight <- name_fi[chain_locate[i]+3] %>% str_split(" ") %>% unlist() %>% as.numeric()
    nt_3_weight <- name_fi[chain_locate[i]+4] %>% str_split(" ") %>% unlist() %>% as.numeric()
    nt_4_weight <- name_fi[chain_locate[i]+5] %>% str_split(" ") %>% unlist() %>% as.numeric()
    nt_weight_matrix <- matrix(
        c(nt_1_weight, nt_2_weight,
          nt_3_weight, nt_4_weight),
        nrow=4,
        byrow = T
    )
    nt_depth <- nt_weight_matrix %>% colMaxs(na.rm = T)
    seq_len <- str_length(nt_depth)
    ## Add NA to depth if the sequence is not complete VDJ
    if(chainInfo$seq_start_aligned[i] > 0){
        ## Add NA if the sequence is not from 0
        nt_depth <- c(rep(NA,  chainInfo$seq_start_aligned[i] - 1), nt_depth)
    }else{
        ## or trim first several nt with minus position
        nt_depth <- nt_depth[(1-chainInfo$seq_start_aligned[i]):length(nt_depth)]
    }
    ## set max length to 120*3
    if(120*3 - chainInfo$seq_end_aligned[i] > 0){
        nt_depth <- c(nt_depth, rep(NA, 120*3 - chainInfo$seq_end_aligned[i]))
    }else{
        nt_depth <- nt_depth[1:(120*3)]
    }
  })
  
  chain_dt=do.call(rbind,chain_count)
  chain_dt[is.na(chain_dt)] <- 0

  ## convert nt data to aa
  chain_aa_dt <- matrix(data = NA, nrow = nrow(chainInfo), ncol = 120, byrow = TRUE)
  for(m in 1:nrow(chain_dt)){
      for(n in 1:120){
          chain_aa_dt[m, n] <- mean(chain_dt[m, (n-1)*3+1], chain_dt[m, (n-1)*3+2], chain_dt[m,(n-1)*3+3], )
      }
  }
  dt_final <- data.frame(
      length_aa= 1:120,
      median_reads= colMedians(chain_aa_dt, na.rm = T),
      up=colQuantiles(chain_aa_dt, probs = 0.75, na.rm = T),
      down=colQuantiles(chain_aa_dt, probs = 0.25, na.rm = T)
  )
  ## prepare position data for cdr rect
  cdr1_min_start <- min(chainInfo$cdr1_start_aligned)/3
  cdr1_max_end <- max(chainInfo$cdr1_end_aligned)/3
  if(is.na(cdr1_min_start) || is.na(cdr1_max_end)){
      cdr1_min_start <- cdr1_start
      cdr1_max_end <- cdr1_end
  }

  cdr2_min_start <- min(chainInfo$cdr2_start_aligned)/3
  cdr2_max_end <- max(chainInfo$cdr2_end_aligned)/3
  if(is.na(cdr2_min_start) || is.na(cdr2_max_end)){
      cdr2_min_start <- cdr2_start
      cdr2_max_end <- cdr2_end
  }
  
  cdr3_min_start <- min(chainInfo$cdr3_start_aligned)/3
  cdr3_max_end <- max(chainInfo$cdr3_end_aligned)/3
  if(is.na(cdr3_min_start) || is.na(cdr3_max_end)){
      cdr3_min_start <- cdr3_start
      cdr3_max_end <- cdr3_end
  }
  if(cdr3_max_end > 125){
      cdr3_max_end <- cdr3_end
  }
  
  p <- ggplot(data = dt_final, 
              mapping = aes(x=length_aa, y = median_reads)) + 
    geom_rect(aes(xmin = cdr1_min_start, xmax = cdr1_max_end, ymin=-Inf,ymax=Inf),
              fill="lightgreen",alpha=0.3)+
    annotate(geom = "text",x=ceiling((cdr1_min_start+cdr1_max_end)/2),y = Inf,
             label="CDR1", vjust=1.5)+
    geom_rect(aes(xmin=cdr2_min_start,xmax=cdr2_max_end,ymin=-Inf,ymax=Inf),
              fill="lightgreen",alpha=0.3)+
    annotate(geom = "text",x=ceiling((cdr2_min_start+cdr2_max_end)/2),y= Inf,
             label="CDR2", vjust=1.5)+
    geom_rect(aes(xmin=cdr3_min_start,xmax=cdr3_max_end,ymin=-Inf,ymax=Inf),
              fill="lightgreen",alpha=0.3)+
    annotate(geom = "text",x=ceiling((cdr3_min_start+cdr3_max_end)/2),y = Inf,
             label="CDR3", vjust=1.5)+
    geom_line(linetype=1)+
    geom_line(mapping = aes(x=length_aa, y=up),linetype=2)+
    geom_line(mapping = aes(x=length_aa, y=down),linetype=2)+
    xlab("VDJ residual (IMGT scheme)")+ylab("UMI/Read Coverage")+
    theme_classic()
  
  if(vdj_type == "BCR_VH"){
    p <- p + ggtitle("IGH")
  }else if(vdj_type == "BCR_VL"){
    p <- p + ggtitle("IGK/L")
  }else if(vdj_type == "TCR_VH"){
    p <- p + ggtitle("TRB/D")
  }else if(vdj_type == "TCR_VL"){
    p <- p + ggtitle("TRA/G")
  }
  return(p)
}
```

```{r include = FALSE}
#A function to analysis VDJ lineages and visualization
# 
# author: yuanzhen (yuanzhen@thunder-bio.com)
#
# parameters:
#
#barcode_report: characters,file path,barcode report from trust4
#airr_report: characters,file path,airr report from trust4
#
#output
#
#a heatmap png of Variable germline gene segment pairing for B-cell repertoires
#a barplot png indicate the number of cells for the top 50 lineages
#a pie plot png indicate the number of cells for the top 50 lineages
#a csv file include the analysis information
#
#
plot_lineages=function(barcode_report_file, airr_report_file){
  
  barcode_report <- read_delim(barcode_report_file,
                               delim = "\t", escape_double = FALSE, 
                               trim_ws = TRUE,show_col_types = F)
  
  suppressWarnings(
      airr <- read_delim(airr_report_file, 
                         delim = "\t", escape_double = FALSE, 
                         trim_ws = TRUE,show_col_types = F)
  )
  

  
  save_csv=.make_clone_type(airr_fe = airr, barcode_fe = barcode_report)
  
  write_csv(save_csv,"barcode_clonetype.csv",quote = "none")
  
  ig_info_all= save_csv%>%
    distinct(.keep_all = TRUE) %>%
    group_by(ig) %>% 
    summarize(type_number = n()) %>%
    mutate(IGH=str_split(ig,"_") %>% sapply("[",1) %>% str_remove("[*][0-9]+"),
           IGL=str_split(ig,"_") %>% sapply("[",4) %>% str_remove("[*][0-9]+"))%>% 
    select(IGH,IGL,type_number) %>%
    filter(IGH!="*") %>%
    filter(IGL!="*") %>% arrange(desc(type_number))
  
  ig_info=ig_info_all%>% 
    dcast(IGH ~ IGL,value.var="type_number") %>%
    column_to_rownames(var = "IGH")
  
  ig_info=ig_info/nrow(ig_info_all)
  #######  heatmap plot ########

  dt_=data.frame(vh=ig_info%>% sapply("[",1) %>% str_remove("r"),
                 vl=ig_info%>% sapply("[",3)%>% str_remove("r")) %>% 
    mutate(ig=str_c(vh,vl)) %>% 
    group_by(ig) %>% 
    mutate(count=n())%>% 
    ungroup() %>% 
    distinct() %>% 
    select(vh,vl,count)
  
  dt_1=dt_ %>%
    pivot_wider(id_cols = vh,names_from = vl,values_from = count) %>%
    column_to_rownames("vh")
  
  dt_1= dt_1/nrow(dt_)
  dt_1[is.na(dt_1)]=0
  
  lineages_count=dt_1 %>% as.matrix()
  lineages_count=lineages_count[,colnames(lineages_count) %>% sort()]
  lineages_count=lineages_count[rownames(lineages_count) %>% sort(),]
  column_ha <- HeatmapAnnotation(
    L = anno_barplot(colSums(lineages_count),border = F),
    show_annotation_name  = F
  )
  row_ha <- rowAnnotation(
    H = anno_barplot(rowSums(lineages_count),
                     axis_param = list(direction = "reverse"),border = F),
    show_annotation_name=F)
  #lineages_count[lineages_count > 0.01]=0.01
  ph <- Heatmap(lineages_count,
            cluster_columns = F,
            cluster_rows = F,
            top_annotation = column_ha, 
            left_annotation = row_ha,
            col = RColorBrewer::brewer.pal(9,"OrRd"),
            column_names_gp = gpar(fontsize = 6),
            row_names_gp = gpar(fontsize = 4),
            heatmap_legend_param = list(title="",at=c(0,max(lineages_count)),labels=c("0",">1%"))
  )
  
  #######  barplot ########
  bar_plot=data.frame(rank=1:50,
                      number_type=ig_info_all$type_number[1:50])
  
  p2=ggplot(bar_plot, aes(x=rank,y=number_type)) + 
    geom_bar(color = 'black', fill='lightblue',stat="identity")+
    xlab("Top 50 lineages")+ylab("No. of cells per lineages")+
    theme_classic()
  
  ######## pie plot ####
  
  info = c(ig_info_all %>% filter(type_number > 1) %>% nrow(), 
           ig_info_all %>% filter(type_number == 1) %>% nrow())
  piepercent = c(paste0(round(info[1]/sum(info),4)*100,"%"), 
                 paste0(round(info[2]/sum(info),4)*100,"%"))
  names = c("Cell in expanded lineages", 
            "Cell in singleton lineages")
  
  cols = c("#3f48CC","grey")
  pie(info,labels=piepercent,col=cols)
  legend("topright", names, cex=1, fill=cols,border = "white")
}

.make_clone_type=function(airr_fe, barcode_fe){

  #airr_fe=airr_fe[!str_detect(airr_fe$sequence_id,"-"),]
  #airr_fe=airr_fe[airr_fe$productive,]
  #airr_fe=airr_fe[airr_fe$complete_vdj,]
  airr_fe$junction_length=str_length(airr_fe$junction)
  barcode_fe =filter(barcode_fe ,`#barcode` %in% airr_fe$sequence_id)
  barcode_fe=barcode_fe[!barcode_fe$chain1=="*",]
  barcode_fe=barcode_fe[!barcode_fe$chain2=="*",]
  barcode_fe$sequence_id=barcode_fe$`#barcode`
  ig_info_all_unf=data.frame(cell_id=barcode_fe$`#barcode`,
                             igh=paste0(barcode_fe$chain1 %>% str_split(",") %>% sapply("[",1),
                                        "_",
                                        barcode_fe$chain1 %>% str_split(",") %>% sapply("[",2),
                                        "_",
                                        barcode_fe$chain1 %>% str_split(",") %>% sapply("[",3)),
                             igk=paste0(barcode_fe$chain2 %>% str_split(",") %>% sapply("[",1),
                                        "_",
                                        barcode_fe$chain2 %>% str_split(",") %>% sapply("[",2),
                                        "_",
                                        barcode_fe$chain2 %>% str_split(",") %>% sapply("[",3)),
                             igh_cdr3=barcode_fe$chain1 %>% str_split(",") %>% sapply("[",6),
                             umi_length_vh=barcode_fe$chain1 %>% str_split(",") %>% sapply("[",7),
                             umi_length_vl=barcode_fe$chain2 %>% str_split(",") %>% sapply("[",7))%>%
    mutate(ig=paste0(igh,"_",igk) ) %>%
    distinct(.keep_all = TRUE) 
  
  
  ig_info_split=split(ig_info_all_unf,ig_info_all_unf$ig)
  
    ig_info_f=lapply(1:length(ig_info_split),function(i){
    xz=ig_info_split[[i]]
    if(nrow(xz)>1){
      m=xz$igh_cdr3
      yz=as.alignment(nb=length(m),nam = 1:length(m),m)
      zt=dist.alignment(yz, matrix = "identity",gap = T) %>% as.matrix()
      t=1-zt^2
      thre=1+(length(m)-1)*0.8
      if(!any(colSums(t)<thre)){
        xz
      }else{
        xz[-which(colSums(t)<thre),]
      }
    }else{
      return(xz)
    }
  })
  
  
  
  ig_info_save=lapply(1:length(ig_info_f),function(x){
    mutate(ig_info_f[[x]],clonetype=x)
  })
  ig_info_save=ig_info_save[-which(lapply(ig_info_save,nrow) %>% unlist ==0)]
  a_tt=do.call(rbind,ig_info_save)
  left_join(a_tt,airr_fe,by=join_by("cell_id"=="sequence_id"))
}
```


```{r modal, echo = FALSE}
expl_tbl <- tribble(
    ~title, ~content,
    "Estimated Number of Cells",
    "The number of barcodes detected as cells",
    "Unique Reads in Cells Mapped to Gene",
    "The number of reads uniquely mapped to gene region in cell associated barcodes",
    "Fraction of Unique Reads in Cells",
    'The fraction of reads uniquely mapped to gene region in cell associated barcodes (divided by total reads uniquely mapped to gene region in all of the barcodes). This value could be interpreted as the "signal to noise ratio"',
    "Mean Reads per Cell",
    "The mean number of reads in the cell associated barcodes",
    "Median Reads per Cell",
    "The median number of reads in the cell associated barcodes",
    "UMIs in Cells",
    "The total number of UMI counts in the cell associated barcodes",
    "Mean UMI per Cell",
    "The mean number of UMI counts in the cell associated barcodes",
    "Median UMI per Cell",
    "The median number of UMI counts in the cell associated barcodes",
    "Mean Gene per Cell",
    "The mean number of genes detected in the cell associated barcodes",
    "Median Gene per Cell",
    "The median number of genes detected in the cell associated barcodes",
    "Total Gene Detected",
    "Total number of genes detected in all of the cell associated barcodes"
)
createModal("cellStats", expl_tbl)

expl_tbl <- tribble(
    ~title, ~content,
    "Knee Plot",
    'The Knee Plot is also called Barcode Rank Plot. The graph displays the number of filtered UMIs assigned to each barcode. The blue color indicates cell associated barcodes, while grey ones are background barcodes. Cell associated barcodes are not solely determined by their UMI count, by default the pipeline will invoke the "EmpytDrops" method, which will compare the expression profile of pre-defined cells and the background, then rescue some "low UMI" cells.'
)
createModal("kneePlot", expl_tbl)

expl_tbl <- tribble(
    ~title, ~content,
    "Number of Reads",
    "Number of read pairs after trimming low quality nucleotides from the end of the cDNA read and discarding too short reads",
    "Reads With Valid Barcodes",
    "Percentage of reads with valid barcode sequence: <li>No mare than 2 N in barcode sequence</li><li>No homopolymer</li><li>Only one mismatch with whitelist</li><li>Reads matches a whitelist barcode with 1 mismatch, but this whitelist barcode does not get any other reads with exact matches of CB were discarded</li>",
    "Sequencing Saturation",
    "The saturation was calculated as 1-nUMI/nReads, which could be used to measure how many reads it will take to sequence a new transcript (UMI). nUMI is the number of UMI, nReads is the number of reads with valid barcode/UMI/Gene. This value represents the complexity of the library. For instance, if the saturation is 75%, then we could only get one new UMI when sequence four more reads.",
    "Q30 Bases in CB+UMI",
    "Percentage of the nucleotides in cell barcode and UMI sequence with the sequencing quality larger than 30 (99% accuracy)",
    "Q30 Bases in RNA read",
    "Percentage of the nucleotides in cDNA reads with sequencing quality larger than 30 (99% accuracy)"
)
createModal("sequencingStats", expl_tbl)

expl_tbl <- tribble(
    ~title, ~content,
    "Mapped to Genome: Unique+Multiple",
    "Total mapping rate of the input reads in spite of barcodes matching",
    "Reads Mapped to Genome: Unique",
    "Fraction of the reads uniquely mapped to the genome in spite of barcodes matching",
    "Reads Mapped to Gene: Unique+Multiple Gene",
    '<blockquote>Multi-gene reads are concordant with (i.e. align equally well to) transcripts of two or more genes. One class of multi-gene read are those that map uniquely to a genomic region where two or more genes overlap. Another class are those reads that map to multiple loci in the genome, with each locus annotated to a different gene.</blockquote> STARsolo will output "NoMulti" if multi-genes reads are not counted',
    "Reads Mapped to Gene: Unique Gene",
    'Fraction of the reads mapped to a unique gene region, this parameter will mostly equivalent to "Reads Mapped Confidently to Transcriptome" in cellranger report',
    "Reads Mapped to Exonic Regions",
    "Fraction of the reads mapped to exonic region",
    "Reads Mapped to Intronic Regions",
    "Fraction of the reads mapped to intronic region",
    "Reads Mapped to Intergenic Regions",
    "Fraction of the reads mapped to intergenic region"
)
createModal("mappingStats", expl_tbl)

expl_tbl <- tribble(
    ~title, ~content,
    "Cell Cluster (colored by cell group)",
    "The UMAP dimension reduction result of the cellular expression profile. Cells with similar expression were assigned to the same group using the unsupervised clustering algorithm of Seurat package. Each scatter represents a cells, colored by the cell group information."
)
createModal("clusterCellGroups", expl_tbl)

expl_tbl <- tribble(
    ~title, ~content,
    "Cell Cluster (colored by UMI density)",
    "The UMAP dimension reduction result of the cellular expression profile. Each scatter represents a cells, colored by the UMI counts detected (log-transformed)."
)
createModal("clusterUMIDensity", expl_tbl)

expl_tbl <- tribble(
    ~title, ~content,
    "Marker Genes of Clusters",
    "After dimension reduction, cells were grouped by unsupervised clustering method (leiden), group specifically expressed genes were tested and the top five genes were listed here."
)
createModal("DEGTable", expl_tbl)

expl_tbl <- tribble(
    ~title, ~content,
    "Cell Metrics",
    "The number of the genes, the UMIs, as well as the mitochondrial UMI percentage in each cell were summarized in a violin plot."
)
createModal("cellMetrics", expl_tbl)

expl_tbl <- tribble(
    ~title, ~content,
    "Gene Coverage",
    "The reads coverage accross the mRNA body. Typical 3' scRNAseq will have a clear peak at the transcript end, while 5' scRNAseq will have higher read counts at the mRNA start."
)
createModal("geneCoverage", expl_tbl)

expl_tbl <- tribble(
    ~title, ~content,
    "Sequencing Saturation",
    "The reads of the library were downsampled at different ratio to calculate the sequencing saturation at different sequencing depth. The saturation was calculated as 1-nUMI/nReads, which could be used to measure how many reads it will take to sequence a new transcript (UMI)"
)
createModal("sequencingDepthCurve", expl_tbl)

expl_tbl <- tribble(
    ~title, ~content,
    "Median Genes per Cell",
    "The reads of the library were downsampled at different ratio to simulate sequencing the library with lower depth, the median value of the genes detected in each cell was calculated to represent a gene-level saturation."
)
createModal("medianGeneCurve", expl_tbl)

expl_tbl <- tribble(
    ~title, ~content,
    "Sample ID",
    "ID of the sample",
    "Pipeline Version",
    "Version of the StarScope pipeline",
    "Reference Dir",
    "The reference genome STAR index file path",
    "Reference GTF",
    "Genome annotation file path",
    "STAR Version",
    "The version of the STAR program",
    "Whitelist Matching",
    "Mothod of matching the cell barcodes to the whiteList. By default we used <code>--soloCBmatchWLtype 1MM_multi_Nbase_pseudocounts</code> parameter, which allows multiple matches in whitelist with 1 mismatched base and a posterior probability will be calcuated to choose one of the matches. Pseudocounts of 1 are added to all whitelist barcodes, multimatching to WL is allowed for CBs with N-bases. This option matches best with CellRanger >= 3.0.0",
    "UMIfiltering",
    "UMI filtering method, by default <code>--soloUMIfiltering MultiGeneUMI_CR</code> will remove UMIs with N and homopolymers as well as lower-count UMIs that map to more than one gene, matching the calculation method in CellRanger > 3.0.0",
    "UMIdedup",
    "Type of UMI deduplication (collapsing) algorithm, by default CellRanger2-4 algorithm for 1MM UMI collapsing was employed, and <code>--soloUMIdedup 1MM_CR</code> parameter was used.",
    "Cell Calling",
    "Cell calling method used in the STARsolo run, by default we employed <b>EmptyDrop</b> method, and <code>--soloCellFilter EmptyDrops_CR</code> parameter was used.",
    "includeIntron",
    "Indicate if reads mapped to intron region were included in the analysis. If it is TRUE here, <code>--soloFeatures GeneFull</code> was used in the STARsolo run, otherwise <code>--soloFeatures Gene</code> was used.",
    "includeMultiReads",
    "Indicate if reads mapped to mulitple genes were included in the analysis, currently not supported and will always be FALSE."
)
createModal("runningInfo", expl_tbl)

expl_tbl <- tribble(
    ~title, ~content,
    "GEX Association",
    "Detected BCR CDR3 clones were projected to cells' UMAP-plot, only paired productive clones were shown. Please note both of the productive and unproductive BCRs are included."
)
createModal("gexAssociation", expl_tbl)

expl_tbl <- tribble(
    ~title, ~content,
    "Knee Plot",
    'Knee Plot was also called as Barcode Rank Plot. The plot shows total UMI (y axis) of each associated barcode (x axis). Foreground cells were selected via cell-calling per "Knee point" as typical scRNAseq experiment, Target (e.g. B/T) cells were further deterimined by their target mRNA UMI (e.g. VDJ UMI) counts (>3). For B or T cells, we retained all the cells either expressing productive or unproductive BCR/TCR mRNAs.'
)
createModal("VDJ_kneePlot", expl_tbl)

expl_tbl <- tribble(
    ~title, ~content,
    "Median IGH UMIs per Cell",
    "Median number of UMIs used to assemble IGH contig.",
    "Median IGK/L UMIs per Cell",
    "Median number of UMIs used to assemble IGK or IGL contig.",
    "Cells with Productive IGH",
    'Number of cells with a productive IGH contig assembled, see below for the definition of the "productive".',
    "Cells with Productive IGK",
    'Number of cells with a productive IGK contig assembled, see below for the definition of the "productive".',
    "Cells with Productive IGL",
    'Number of cells with a productive IGL contig assembled, see below for the definition of the "productive".',
    "Cells with Productive IGKIGH pair",
    'Number of cells with both a productive IGK contig and a productie IGH contig assembled, see below for the definition of the "productive".',
    "Cells with Productive IGLIGH pair",
    'Number of cells with both a productive IGL contig and a productie IGH contig assembled, see below for the definition of the "productive".',
    "Productive",
    "We follow the <a href='https://docs.airr-community.org/en/v1.5.0/datarep/rearrangements.html#productive'><b>AIRR Standards</b></a> to define productive BCR/TCR: <li>Coding region has an open reading frame</li><li>No defect in the start codon, splicing sites or regulatory elements.</li><li>No internal stop codons.</li><li>An in-frame junction region.</li>"
)
createModal("BCR_annotation", expl_tbl)

expl_tbl <- tribble(
    ~title, ~content,
    "Median TRB/TRD UMIs per Cell",
    "Median number of UMIs used to assemble TRB or TRD contig.",
    "Median TRA/TRG UMIs per Cell",
    "Median number of UMIs used to assemble TRA or TRG contig.",
    "Cells with Productive TRB",
    'Number of cells with a productive TRB contig assembled, see below for the definition of the "productive".',
    "Cells with Productive TRD",
    'Number of cells with a productive TRD contig assembled, see below for the definition of the "productive".',
    "Cells with Productive TRA",
    'Number of cells with a productive TRA contig assembled, see below for the definition of the "productive".',
    "Cells with Productive TRG",
    'Number of cells with a productive TRG contig assembled, see below for the definition of the "productive".',
    "Cells with Productive TRATRB pair",
    'Number of cells with both a productive TRA contig and a productie TRB contig assembled, see below for the definition of the "productive".',
    "Cells with Productive TRGTRD pair",
    'Number of cells with both a productive TRG contig and a productie TRD contig assembled, see below for the definition of the "productive".',
    "Productive",
    "We follow the <a href='https://docs.airr-community.org/en/v1.5.0/datarep/rearrangements.html#productive'><b>AIRR Standards</b></a> to define productive BCR/TCR: <li>Coding region has an open reading frame</li><li>No defect in the start codon, splicing sites or regulatory elements.</li><li>No internal stop codons.</li><li>An in-frame junction region.</li>"
)
createModal("TCR_annotation", expl_tbl)

expl_tbl <- tribble(
    ~title, ~content,
    "Clones (Paired)",
    "Here we counted unique CDR3 nucleotides pairs with identical germline VDJ gene segments as different clones. This result includes all the paired ones from the clonotype table.",
    "Lineage Number",
    "Number of the lineages identified from the paired clones. The cells in the same lineage are required to have identical VH and VL germline gene segments and at least 80% nucleotide identity in the CDR-H3 region.",
    "Single Cell Lineage Number",
    "Number of the lineages which have only one cell member.",
    "Multiple Cell Lineage Number",
    "Number of the lineages which have more then one cells.",
    "Cells in Multiple Cell Lineages",
    "Number of the total cells from the multiple cell lineage.",
    "Total Cells with Paired Clones",
    "Total number of the cells taken into the lineage analysis, reuqiring both the VH and VL chains detected.",
    "Pairing Accuracy",
    'The pairing accuracy were estimated under the assumption that all the T/B cells are mature and VDJ recombination steps have been finished. Thus there is very little chance two cells having the same VDJ germline segments on both VH and VL chain. We grouped all the cells with identical heavy chain VDJ and CDRH3 sequence, and identified the cells with disconcordant light chain VDJ segments as "platform pairing error" cells. The percentage of concordant cells was used to estimtate accuracy.',
    "Shannon Entropy & Clonality",
    '<blockquote cite>The Shannon entropy index is a measure used for repertoire diversity using clonotype frequencies, which reflects both richness and evenness of the repertoire. This measure informs us of the probability that two random selections from the same repertoire would represent the same clonotype. Clonality can be measured using normalized entropy over the number of unique clones (1-shannon entropy/log(N), where N is the number of unique clones). It is equivalent to 1 - Pielou’s Evenness, making it inversely proportional to diversity. A higher clonality index indicates an uneven repertoire due to expansion of clones.<footer>https://liulab-dfci.github.io/RIMA/Repertoire.html#tcr-and-bcr-entropy-and-clonality</footer></blockquote>'
)
createModal("Lineage_annotation", expl_tbl)


expl_tbl <- tribble(
    ~title, ~content,
    "Pie Chart",
    "Pie chart summarized percentage of cells in expanded lineages (blue) and cells in singleton lineage (grey).",
    "Bar Chart",
    "Bar chart summarized cell counts in up to top 50 expanded lineages."
)
createModal("Lineage_plot", expl_tbl)

expl_tbl <- tribble(
    ~title, ~content,
    "V Region Coverage",
    "UMI or Read coverage for assembled VH or VL contigs. Positions within VH and VL are based on IMGT scheme numbers, CDR regions are indicated by shaded regions. Solid lines indicate the median, dashed lines interquartile range."
)
createModal("Chain_coverage", expl_tbl)

expl_tbl <- tribble(
    ~title, ~content,
    "Top 1000 Clonotypes",
    "Clonotypes are defined as the same VH and VL CDR3 <b>nucleotide</b> sequences as well as identical VDJ combinations. Here cells generating unproductive chain or with only one chain detected are also included. If multiple heavy or light chain contigs were obtained, only the most abundant one will be shown."
)
createModal("Clonetypes_top1000", expl_tbl)

expl_tbl <- tribble(
    ~title, ~content,
    "Top 10 Clonotypes",
    "The histogram depicts cell counts of the top 10 abundant clonotypes. Clonotypes with only one chain detected or from unproductive chain are also included. The clonotype IDs on the X axis correspond to the clonotype IDs listed in the table."
)
createModal("Clonetypes_top10", expl_tbl)

expl_tbl <- tribble(
    ~title, ~content,
    "Estimated Number of Cells",
    "The number of detected cells expressing VDJ transcripts. We used VDJ UMI > 3 to filter background barcodes, and cells with either productive or unproductive VDJ chains are counted.",
    "Reads in Cells Mapped to VDJ Gene",
    "Number of reads with valid barcodes in the estimated cells that map to any germline V(D)J gene segment and used for VDJ contig assembly.",
    "Fraction of Reads Used in Assembly",
    "Fraction of reads with valid barcodes in the estimated cells that map to any germline V(D)J gene segment and used for VDJ contig assembly.",
    "Mean VDJ Reads per Cell",
    "Number of VDJ reads in the estimated VDJ cells divided by cell counts.",
    "Median VDJ Reads per Cell",
    "Median number of the VDJ reads in the estimated cells.",
    "Mean Total UMIs per Cell",
    "Number of the total UMIs (VDJ UMI + none-VDJ UMI) in the estimated VDJ cells divided by cell counts.",
    "Median Total UMIs per Cell",
    "Median of the total UMIs (VDJ UMI + none-VDJ UMI) in the estimated VDJ cells.",
    "Pairing Rate",
    "The number of detected cells expressing both heavy chain and light chain transcripts divided by the total number of cells.",
    "Total Clonotypes Detected",
    "Number of clonotypes detected. Clonotypes are defined as the same VH and VL CDR3 amino acid sequences as well as identical VDJ combinations."
)
createModal("VDJ_stats", expl_tbl)

expl_tbl <- tribble(
    ~title, ~content,
    "Number of Reads",
    "Number of the input reads after trimming low quality (Q30) bases from cDNA reads and discarding reads that are too short.",
    "Reads With Valid Barcodes",
    "Fraction of reads with a valid barcode in the whitelist after barcodes correction.",
    "Sequencing Saturation",
    "Sequencing saturation is estimated by counting reads belonging to the same UMI, which is an indicator of the library complexity. A 75% saturation indicates that user will have to sequence 4 more reads to obtain a new UMI (mRNA transcript).",
    "Q30 Bases in CB+UMI",
    "Fraction of the CB+UMI reads bases with Q-score >= 30, indicating 99.9% sequence accuracy.",
    "Q30 Bases in RNA read",
    "Fraction of the cDNA reads bases with Q-score >= 30, indicating 99.9% sequence accuracy."
)
createModal("Sequencing_stats", expl_tbl)
```


`r if(!include_gex){"\\begin{comment}"} else {NULL}`

```{r process_gex, include = FALSE, eval = include_gex}
is_number_string <- function(x){
    str_split(x, pattern="") %>% 
        unlist %>% str_detect("[0-9.]") %>% 
        all()
}
starsolo_summary <- read_csv(params$starsolo_out,
                             col_names = c("item", "value"),
                             col_types = cols("c", "c"))
starsolo_summary$data <- NA
for(i in 1:nrow(starsolo_summary)){
    if(is_number_string(starsolo_summary$value[i])){
        if(as.numeric(starsolo_summary$value[i]) >= 1){
            starsolo_summary$data[i] <- comma(as.numeric(starsolo_summary$value[i]), accuracy = 1)
        }else{
            starsolo_summary$data[i] <- percent(as.numeric(starsolo_summary$value[i]))
        }
    }else{
        starsolo_summary$data[i] <- starsolo_summary$value[i]
    }
}
starsolo_summary <- starsolo_summary %>%
    select(-value) %>%
    dplyr::rename("value" = "data") %>%
    mutate(item=str_replace_all(item, "GeneFull", "Gene"))

exon_ratio <- fromJSON(params$featureStats)$exonRatio %>% as.numeric
intron_ratio <- fromJSON(params$featureStats)$intronRatio %>% as.numeric
intergenic_ratio <- fromJSON(params$featureStats)$intergenicRatio %>% as.numeric

STARSolo <- Read10X(data.dir=file.path(params$starsolo_matrixDir))
seuratData <- CreateSeuratObject(counts=STARSolo,
                             min.cells=0,
                             min.features=0, project=params$sampleName)
seuratData[['run']]=params$sampleName
seuratData[["percent.mt"]]=PercentageFeatureSet(object=seuratData, pattern = "MT-|mt-")

## Plot the genes counts, RNAs counts and mitochondrial proportions.
qcPlot <- VlnPlot(object=seuratData, features=c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol=3, group.by="run")

## Filter by gene counts and mitochondrial percentage
## Check the number of cells left first, or subset will throw an error
filtered_cells <- seuratData@meta.data %>% 
    filter(nFeature_RNA > max(200, as.numeric(params$nFeature_RNA_lower)),
           percent.mt < as.numeric(params$percent_mt_cutoff)) %>% 
           nrow
message("filtered_cells is ", filtered_cells)
if(filtered_cells>0){
    seuratData <- subset(
        seuratData, 
        nFeature_RNA > as.numeric(params$nFeature_RNA_lower) & percent.mt < as.numeric(params$percent_mt_cutoff)
    )
    filtered_cells <- seuratData@meta.data %>% nrow
}

## Only perform clustering when more than 150 cells detected
if(filtered_cells >= 150){
    ## Normalization and scaling
    seuratData <- NormalizeData(object=seuratData)
    seuratData <- FindVariableFeatures(seuratData)
    seuratData <- ScaleData(seuratData)
    
    seuratData <- RunPCA(object=seuratData, npcs=100)
    
    ## set pca_dim to be used, 30
    pca_dim <- as.numeric(params$pca_dim)
    ## set resolution
    resolution <- as.numeric(params$resolution)
    
    seuratData <- FindNeighbors(object=seuratData, reduction="pca", dims=1:pca_dim)
    seuratData <- FindClusters(object=seuratData, resolution=resolution)
    seuratData <- RunUMAP(object=seuratData, reduction="pca", dims=1:pca_dim)
    
    ##Idents(object=seuratData) <- paste("RNA_snn_res.", resolution, sep="")
    ##clusterPlot <- DimPlot(object=seuratData, reduction="umap", label=TRUE, repel=TRUE)
}
```



GEX {data-orientation=rows}
====================

<h2 style="margin-top: 0.5rem; font-weight: bold;">Sample: `r params$sampleName` (GEX)</h2>

Row
----------

### Estimated Number of Cells

```{r eval = include_gex}
cellNum <- starsolo_summary %>% 
    filter(item == "Estimated Number of Cells") %>% 
    pull(value)
valueBox(cellNum, icon = "fa-circle-notch", color = "info")
```

### Mean Reads per Cell

```{r eval = include_gex}
totalReads <- starsolo_summary %>% 
    filter(item == "Number of Reads") %>% 
    pull(value)
readsMean <- (as.numeric(str_remove_all(totalReads, ",")) / as.numeric(str_remove_all(cellNum, ","))) %>% 
    round() %>%
    label_comma()()
valueBox(readsMean, icon = "fa-chart-bar", color = "primary")
```

### Median Genes per Cell

```{r eval = include_gex}
medianGenePerCell <- starsolo_summary %>% 
    filter(str_detect(item, regex("Median Gene(Full)* per Cell"))) %>% 
    pull(value)
valueBox(medianGenePerCell, icon = "fa-barcode", color = "warning")
```

Row
----------

### Cell Stats `r infoIcon("cellStats")`

```{r eval = include_gex}
d <- starsolo_summary %>% 
    filter(item %in% c("Estimated Number of Cells",
                       "Unique Reads in Cells Mapped to Gene",
                       "Unique Reads in Cells Mapped to GeneFull",
                       "Reads in Cells Mapped to Gene",
                       "Fraction of Unique Reads in Cells",
                       "Fraction of Reads in Cells",
                       "Mean Reads per Cell",
                       "Median Reads per Cell",
                       "UMIs in Cells",
                       "Mean UMI per Cell",
                       "Median UMI per Cell",
                       "Mean Gene per Cell",
                       "Mean GeneFull per Cell",
                       "Median Gene per Cell",
                       "Median GeneFull per Cell",
                       "Total Gene Detected",
                       "Total GeneFull Detected"))

d <- d %>% 
    mutate(item = str_replace(item, "Mean Reads per Cell", "Mean Reads per Cell (STARsolo style)"))
idx <- which(d$item == "Mean Reads per Cell (STARsolo style)")
d <- d %>%
    add_row(item = "Mean Reads per Cell (cellRanger style)", value = readsMean, .before = idx)

names(d) <- c("","")                       
d %>% kbl() %>% kable_paper("hover", html_font = html_font)
```

### Knee Plot `r infoIcon("kneePlot")`

```{r eval = include_gex}
umi_dist <- read_tsv(params$starsolo_bc, col_names =c("UMI"))
cellNum <- str_replace(cellNum, ",", "") %>% as.numeric()
umi_dist <-  umi_dist %>%
    mutate(
        cell = c(1:nrow(umi_dist)),
        group = case_when(
            cell <= cellNum ~ "cell",
            TRUE ~ "background"
            )
        )

fig <- plot_ly(data = umi_dist, x = ~cell, y = ~UMI, type = 'scatter', mode = 'lines',
               color = ~group, colors = c('grey', '#002366'),
               hovertemplate = 'UMI: %{y}<extra>%{fullData.name}</extra>',
               line = list(width = 3),
               height = 400, width = 360)
fig <- layout(fig, xaxis = list(title = "Barcode Rank", type = "log"),yaxis = list(type = "log"), showlegend = FALSE)
config_plotly_fig(fig) %>% toWebGL()

##ggplot(umi_dist, aes(x=cell, y=UMI, color = group)) + 
##    geom_point(alpha = 0.8) +
##    geom_vline(xintercept = cellNum, 
##               linetype = "dashed", color = "grey") +
##    scale_x_log10(n.breaks = 8, labels = scales::label_number_si()) + 
##    scale_y_log10(n.breaks = 5, labels = scales::label_number_si()) +
##    scale_color_manual(values =c("grey", "royalblue")) +
##    xlab("Cell") + ylab("UMI") +
##    theme_bw() + 
##    theme(panel.grid = element_blank(), 
##          axis.text = element_text(color="black"),
##          legend.position = "none")
```

Row {data-height=400}
----------

### Sequencing Stats `r infoIcon("sequencingStats")`

```{r eval = include_gex}
d <- starsolo_summary %>% 
    filter(item %in% c("Number of Reads",
                       "Reads With Valid Barcodes",
                       "Sequencing Saturation",
                       "Q30 Bases in CB+UMI",
                       "Q30 Bases in RNA read",
                       "Total Gene Detected",
                       "Total GeneFull Detected"))
names(d) <- c("","")
d %>% kbl() %>% kable_paper("hover", html_font = html_font)
                                        
```

### Mapping Stats `r infoIcon("mappingStats")`

```{r eval = include_gex}
d <- starsolo_summary %>% 
    filter(item %in% c("Reads Mapped to Genome: Unique+Multiple",
                       "Reads Mapped to Genome: Unique",
                       "Reads Mapped to Gene: Unique+Multiple Gene",
                       "Reads Mapped to GeneFull: Unique+Multiple GeneFull",
                       "Reads Mapped to Gene: Unique Gene",
                       "Reads Mapped to GeneFull: Unique GeneFull")) %>%
    add_row(item = "Reads Mapped to Exonic Regions", value = label_percent(0.01)(exon_ratio)) %>%
    add_row(item = "Reads Mapped to Intronic Regions", value = label_percent(0.01)(intron_ratio)) %>%
    add_row(item = "Reads Mapped to Intergenic Regions", value = label_percent(0.01)(intergenic_ratio))
names(d) <- c("","")
d %>% kbl() %>% kable_paper("hover", html_font = html_font)
```

Row
----------

### Cell Cluster (colored by cell group) `r infoIcon("clusterCellGroups")`

```{r eval = include_gex}
## Only plot cluster when there are more than 150 filtered cells
if(filtered_cells >= 150){
    ##clusterPlot <- DimPlot(object=seuratData, reduction="umap", label=TRUE, repel=TRUE)
    ## extract data from seuratData
    umap_data <- Embeddings(object = seuratData[["umap"]])[colnames(seuratData), c(1, 2)]
    clusterData <- merge(umap_data, seuratData@meta.data, by=0) %>% 
        dplyr::rename("bc" = `Row.names`)
    cellCount <- clusterData %>% group_by(seurat_clusters) %>% summarise(cellCount = n())
    totalCell <- cellCount %>% pull(cellCount) %>% sum()
    clusterData <- clusterData %>% left_join(cellCount, by = "seurat_clusters") %>%
        mutate(totalCell=totalCell,
               text = paste0(cellCount, "/", totalCell))
    
    plot_ly(clusterData, x = ~UMAP_1, y= ~UMAP_2, color = ~seurat_clusters, 
            text = ~text,
            type = 'scatter', mode = 'markers',
            colors = 'Dark2',
            hovertemplate = 'cells: %{text}<extra><b>Cluster: %{fullData.name}</b></extra>') %>%
        config_plotly_fig() %>%
        toWebGL()
    
    ##clusterPlot %>% ggplotly() %>%
    ##    config(displaylogo = FALSE,
    ##           modeBarButtonsToRemove = c('zoom', 'pan', 'select', 'zoomIn', 'zoomOut', 'autoScale',
    ##                                      'hoverClosestCartesian', 'hoverCompareCartesian')) %>% toWebGL()
}else{
    cat("Too few cells: ", filtered_cells, "(filtered by nFeature >= 200)\n")
}
```

### Cell Cluster (colored by read depth) `r infoIcon("clusterUMIDensity")`

```{r eval = include_gex}
if(filtered_cells >= 150){
clusterData <- clusterData %>%
    mutate(log10_UMI = log10(nCount_RNA))
    
plot_ly(clusterData, x = ~UMAP_1, y= ~UMAP_2, color = ~log10_UMI,  text = ~nCount_RNA,
        type = 'scatter', mode = 'markers',
        hovertemplate = 'UMI: %{text}<extra></extra>') %>%
    config_plotly_fig() %>%
    toWebGL()

##depthPlot <- FeaturePlot(object = seuratData, features = 'log_nCount_RNA') + scale_color_continuous(name="log10 Read Counts", type = "viridis", direction = 1) + labs(title = NULL)
##depthPlot %>% ggplotly() %>%
##    config(displaylogo = FALSE, 
##           modeBarButtonsToRemove = c('zoom', 'pan', 'select', 'zoomIn', 'zoomOut', 'autoScale',
##                                      'hoverClosestCartesian', 'hoverCompareCartesian')) %>% toWebGL()
}else{
    cat("Too few cells: ", filtered_cells, "(filtered by nFeature >= 200)\n")
}
```

Row {style="margin-right: 8px"}
----------

### Marker Genes of Clusters (top5) `r infoIcon("DEGTable")` {style="width: 100% !important"}

```{r eval = include_gex}
if(filtered_cells >= 150){
    markerGenes <- FindAllMarkers(seuratData, only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25)
    if("cluster" %in% colnames(markerGenes)){
        markerGenes %>%
            group_by(cluster) %>%
            slice_max(n = 5, order_by = avg_log2FC) %>% 
            dplyr::relocate(gene, .before=1) %>%
            mutate(p_val = signif(p_val, 3),
                   avg_log2FC = signif(avg_log2FC, 3),
                   p_val_adj = signif(p_val_adj, 3)) %>%
            DT::datatable(rownames = FALSE, width = "100%",
                          options = list(scrollX = T, scrollY = F, pageLength = 10))
    }else{
        cat("No DEGs detected.\n")
    }
}else{
    cat("Too few cells: ", filtered_cells, "(filtered by nFeature >= 200)\n")
}
```

```{r include=FALSE, eval = include_gex}
if(filtered_cells >= 150 && ("cluster" %in% colnames(markerGenes))){
    markerGenes %>%
        group_by(cluster) %>%
        dplyr::relocate(gene, .before=1) %>%
        write_tsv(paste0(params$sampleName, "_DEG.tsv"))
}
```

Row
----------

### Cell Metrics `r infoIcon("cellMetrics")`

```{r eval = include_gex}
qcPlot
```

### Gene Coverage `r infoIcon("geneCoverage")`

```{r eval = include_gex}
dep <- read_tsv(params$geneCoverage, skip=3, col_names = NULL) %>% apply(2, sum, na.rm = TRUE)
geneCoverage_df <- tibble(pos = 1:length(dep), dep = dep)
ggplot(geneCoverage_df, aes(x=`pos`, y=`dep`)) +
    geom_line(size=1, color = "#551a8b", alpha=0.8) +
    scale_y_continuous(labels = label_number(scale_cut = cut_short_scale())) +
    xlab("Transcript Relative Position")+ylab("Read Coverage")+
    theme_bw() + theme(panel.grid = element_blank())
```


Row
----------

### Sequencing Saturation `r infoIcon("sequencingDepthCurve")`

```{r eval = include_gex}
saturation_data <- fromJSON(params$saturation_json)
saturation_data <- saturation_data[["saturation_data"]] %>%
    as_tibble() %>%
    mutate(across(.col = everything(), .fns = as.numeric))

plot_ly(saturation_data, x = ~reads, y= ~saturation,
        type = 'scatter', mode = 'lines',
        hovertemplate = 'Read depth: %{x}<br>Saturation: %{y}<extra></extra>') %>%
    config_plotly_fig() %>%
    toWebGL()
```

### Median Genes per Cell `r infoIcon("medianGeneCurve")`

```{r eval = include_gex}
plot_ly(saturation_data, x = ~meanReadPerCell, y= ~medianGenePerCell,
        type = 'scatter', mode = 'lines',
        hovertemplate = 'Mean read per cell: %{x}<br>Median gene per cell: %{y}<extra></extra>') %>%
    config_plotly_fig() %>%
    toWebGL()
```

```{r include=FALSE, eval = include_gex}
d <- starsolo_summary %>% 
    filter(item %in% c("Estimated Number of Cells",
                       "Unique Reads in Cells Mapped to Gene",
                       "Unique Reads in Cells Mapped to GeneFull",
                       "Fraction of Unique Reads in Cells",
                       "Mean Reads per Cell",
                       "Median Reads per Cell",
                       "UMIs in Cells",
                       "Mean UMI per Cell",
                       "Median UMI per Cell",
                       "Mean Gene per Cell",
                       "Mean GeneFull per Cell",
                       "Median Gene per Cell",
                       "Median GeneFull per Cell",
                       "Total Gene Detected",
                       "Total GeneFull Detected",
                       "Number of Reads",
                       "Reads With Valid Barcodes",
                       "Sequencing Saturation",
                       "Q30 Bases in CB+UMI",
                       "Q30 Bases in RNA read",
                       "Reads Mapped to Genome: Unique+Multiple",
                       "Reads Mapped to Genome: Unique",
                       "Reads Mapped to Gene: Unique+Multiple Gene",
                       "Reads Mapped to GeneFull: Unique+Multiple GeneFull",
                       "Reads Mapped to Gene: Unique Gene",
                       "Reads Mapped to GeneFull: Unique GeneFull")) %>%
    add_row(item = "Reads Mapped to Exonic Regions", value = label_percent(0.01)(exon_ratio)) %>%
    add_row(item = "Reads Mapped to Intronic Regions", value = label_percent(0.01)(intron_ratio)) %>%
    add_row(item = "Reads Mapped to Intergenic Regions", value = label_percent(0.01)(intergenic_ratio)) %>%
    add_row(item = "sampleID", value = params$sampleName, .before = 1)

d <- d %>% 
    mutate(item = str_replace(item, "Mean Reads per Cell", "Mean Reads per Cell (STARsolo style)"))
idx <- which(d$item == "Mean Reads per Cell (STARsolo style)")
d <- d %>%
  add_row(item = "Mean Reads per Cell (cellRanger style)", value = readsMean, .before = idx)
d %>% write_tsv(paste0(params$sampleName, ".metrics.tsv"))
d %>% pivot_wider(names_from = item, values_from= value) %>% 
    write_json(paste0(params$sampleName, ".metrics.json"), pretty=TRUE)
```

`r if(!include_gex) {"\\end{comment}"} else {NULL}`

`r if(!include_tcr) {"\\begin{comment}"} else {NULL}`

VDJ-T {data-orientation=rows}
====================

<h2 style="margin-top: 0.5rem; font-weight: bold;">Sample: `r params$sampleName` (VDJ-T)</h2>

```{r include=FALSE, eval = include_tcr}
vdj_t_cells <- read_tsv(params$VDJ_T_cells)
vdj_t_combinedInfo <- combineInfo(cells = vdj_t_cells$CB, 
                                  barcode_report = params$VDJ_T_report,
                                  airr_report = params$VDJ_T_airr)

vdj_t_cloneType <- vdj_t_combinedInfo %>%
    dplyr::select(chain1_cdr3aa, chain2_cdr3aa, chain1_V, chain1_D, chain1_J, chain2_V, chain2_J) %>%
    group_by(chain1_cdr3aa, chain2_cdr3aa, chain1_V, chain1_D, chain1_J, chain2_V, chain2_J) %>%
    summarize(cellCount = n()) %>%
    ungroup() %>%
    mutate(
        label1 = case_when(
            !is.na(chain1_V) ~ str_sub(chain1_V, 1L, 3L),
            !is.na(chain1_D) ~ str_sub(chain1_D, 1L, 3L),
            !is.na(chain1_J) ~ str_sub(chain1_J, 1L, 3L),
            TRUE ~ "Heavy"
        ),
        label2 = case_when(
            !is.na(chain2_V) ~ str_sub(chain2_V, 1L, 3L),
            !is.na(chain2_J) ~ str_sub(chain2_J, 1L, 3L),
            TRUE ~ "Light"
        ),
        Hchain_VDJ = paste0(chain1_V, "|", chain1_D, "|", chain1_J),
        Lchain_VDJ = paste0(chain2_V, "|", chain2_J)
    ) %>%
    mutate(
        cloneType = case_when(
            !is.na(chain1_cdr3aa) & !is.na(chain2_cdr3aa) ~ paste0(label1, ":", chain1_cdr3aa, ";", label2, ":", chain2_cdr3aa),
            is.na(chain1_cdr3aa) ~ paste0(label2, ":", chain2_cdr3aa),
            is.na(chain2_cdr3aa) ~ paste0(label1, ":", chain1_cdr3aa)
        )
    ) %>%
    arrange(desc(cellCount)) %>%
    mutate(Frequency = cellCount/nrow(vdj_t_combinedInfo)) %>%
    dplyr::select(cloneType, Hchain_VDJ, Lchain_VDJ, cellCount, Frequency)

vdj_t_cloneType$Hchain_VDJ[which(vdj_t_cloneType$Hchain_VDJ == "NA|NA|NA")] <- NA
vdj_t_cloneType$Lchain_VDJ[which(vdj_t_cloneType$Lchain_VDJ == "NA|NA")] <- NA
    
vdj_t_cloneType <- vdj_t_cloneType %>%
    mutate(
        id = 1:nrow(vdj_t_cloneType),
        Frequency = scales::label_percent(0.01)(Frequency)
    )
write_tsv(vdj_t_combinedInfo, file = paste0(params$sampleName, "_TCR_results.tsv"))
write_tsv(vdj_t_cloneType, file = paste0(params$sampleName, "_TCR_clonotypes.tsv"))
```

Row
----------

### Estimated Number of Cells


```{r include = FALSE, eval = include_tcr}
vdj_t_metrics <- fromJSON(params$VDJ_T_metrics)
```

```{r eval = include_tcr}
valueBox(vdj_t_metrics$cells %>% as.numeric() %>% label_comma()(), icon = "fa-circle-notch", color = "info")
```

### Mean VDJ Reads per Cell

```{r eval = include_tcr}
valueBox(vdj_t_metrics$meanVDJReadsPerCell %>% as.numeric() %>% round %>% label_comma()(), icon = "fa-chart-bar", color = "primary")
```

### Total Clonotypes Discovered

```{r eval = include_tcr}
valueBox(nrow(vdj_t_cloneType) %>% label_comma()(), icon = "fa-barcode", color = "warning")
```

Row
----------

### VDJ Stats `r infoIcon("VDJ_stats")`

```{r eval = include_tcr}
##Estimated Number of Cells
##Reads in Cells Mapped to Gene
##Fraction of Reads in Cells
##Mean Reads per Cell
##Median Reads per Cell
##UMIs in Cells
##Mean UMI per Cell
##Median UMI per Cell
##Mean Gene per Cell
##Median Gene per Cell

fractionAssembled <- as.numeric(vdj_t_metrics$totalReadsInCell)/(as.numeric(vdj_t_metrics$totalRawReads)*as.numeric(vdj_t_metrics$validBCreads))
fractionAssembled <- as.character(fractionAssembled)

vdj_t_tbl <- tribble(
  ~term, ~value,
  "Estimated Number of Cells (including non-pairing cells)", vdj_t_metrics$cells,
  "Reads in Cells Mapped to VDJ Gene", vdj_t_metrics$totalReadsInCell,
  "Fraction of Reads Used in Assembly", fractionAssembled,
  "Mean VDJ Reads per Cell", vdj_t_metrics$meanVDJReadsPerCell,
  "Median VDJ Reads per Cell", vdj_t_metrics$medianVDJReadsPerCell,
  "Mean Total UMIs per Cell", vdj_t_metrics$meanTotalUMIsPerCell,
  "Median Total UMIs per Cell", vdj_t_metrics$medianTotalUMIsPerCell,
  "Pairing Rate", vdj_t_metrics$pairingRate,
  "Total Clonotypes Detected", vdj_t_metrics$totalCloneTypes
) %>%
  mutate(value = as.numeric(value)) %>%
  mutate(value=case_when(value <= 1 ~ label_percent(0.01)(value),
                         value > 1 ~ label_comma()(round(value))))
                         
## Rename UMI terms
if(!params$withUMI){
    vdj_t_tbl$term[which(vdj_t_tbl$term=="Mean Total UMIs per Cell")] <- "Mean Total Reads per Cell"
    vdj_t_tbl$term[which(vdj_t_tbl$term=="Median Total UMIs per Cell")] <- "Median Total Reads per Cell"
}

vdj_t_stats <- vdj_t_tbl

names(vdj_t_tbl) <- c("", "")
vdj_t_tbl %>% 
    kbl() %>% 
    kable_paper("hover", html_font = html_font)
```

### Knee Plot `r infoIcon("VDJ_kneePlot")`

```{r eval = include_tcr}
cellNum <- as.numeric(vdj_t_metrics$cells)
vdj_t_kneeData <- read_tsv(params$VDJ_T_kneeOut, col_names = c("CB", "UMI"))

vdj_t_knee <- vdj_t_kneeData %>% 
    mutate(
        cell = c(1:nrow(vdj_t_kneeData)),
        group = case_when(
            CB %in% vdj_t_cells$CB ~ "cell",
            TRUE ~ "background"
        )
    )
fig <- plot_ly(data = vdj_t_knee, x = ~cell, y = ~UMI, type = 'scatter', mode = 'lines',
               color = ~group, colors = c('grey', '#002366'),
               hovertemplate = 'UMI: %{y}<extra>%{fullData.name}</extra>',
               line = list(width = 3),
               height = 400, width = 360)
fig <- layout(fig, xaxis = list(title = "Barcode Rank", type = "log"),yaxis = list(type = "log"), showlegend = FALSE)

if(!params$withUMI){
    fig <- layout(fig, yaxis = list(title = "Reads"))
}

config_plotly_fig(fig) %>% toWebGL()
```

Row {data-height=350}
----------

### Sequencing Stats `r infoIcon("Sequencing_stats")`

```{r eval = include_tcr}
##Number of Reads
##Reads With Valid Barcodes
##Sequencing Saturation
##Q30 Bases in CB+UMI
##Q30 Bases in RNA read
##Total VDJ Gene Fragments Detected
vdj_t_tbl <- tribble(
  ~term, ~value,
  "Number of Reads", vdj_t_metrics$totalRawReads,
  "Reads With Valid Barcodes", vdj_t_metrics$validBCreads,
  "Sequencing Saturation", vdj_t_metrics$saturation,
  "Q30 Bases in CB+UMI", vdj_t_metrics$q30InCBandUMI,
  "Q30 Bases in RNA read", vdj_t_metrics$q30InRNA
) %>%
  mutate(value = as.numeric(value)) %>%
  mutate(value=case_when(value <= 1 ~ label_percent(0.01)(value),
                         value > 1 ~ label_comma()(round(value))))
                         
vdj_t_sequencing_stats <- vdj_t_tbl

names(vdj_t_tbl) <- c("", "")
vdj_t_tbl %>% 
    kbl() %>% 
    kable_paper("hover", html_font = html_font)
```

### V(D)J Annotation `r infoIcon("TCR_annotation")`

```{r eval = include_tcr}
##Cells with productive V-J spanning pair
##Cells with productive V-J spanning (IGK, IGH) pair
##Cells with productive V-J spanning (IGL, IGH) pair
##Cells with productive IGH contig
##Cells with productive IGK contig
##Cells with productive IGL contig
##Paired clonotype diversity
medianUMIsChain1 <- vdj_t_combinedInfo %>% 
    pull(chain1_expr) %>% median(na.rm = TRUE) %>% round()
medianUMIsChain2 <- vdj_t_combinedInfo %>%
    pull(chain2_expr) %>% median(na.rm = TRUE) %>% round()
cellsWithProductiveChainTRB <- vdj_t_combinedInfo %>%
    filter(chain1_productive, chain1_type == "TRB") %>% nrow()
cellsWithProductiveChainTRA <- vdj_t_combinedInfo %>%
    filter(chain2_productive, chain2_type == "TRA") %>% nrow()
cellsWithProductiveChainTRD <- vdj_t_combinedInfo %>%
    filter(chain1_productive, chain1_type == "TRD") %>% nrow()
cellsWithProductiveChainTRG <- vdj_t_combinedInfo %>%
    filter(chain2_productive, chain2_type == "TRG") %>% nrow()
cellsWithProductiveChainTRATRB <- vdj_t_combinedInfo %>%
    filter(chain1_productive, 
           chain2_productive, 
           chain1_type == "TRB", 
           chain2_type == "TRA") %>% 
    nrow()
cellsWithProductiveChainTRGTRD <- vdj_t_combinedInfo %>%
    filter(chain1_productive, 
           chain2_productive, 
           chain1_type == "TRD", 
           chain2_type == "TRG") %>% 
    nrow()

vdj_t_tbl <- tribble(
  ~term, ~value,
  "Median TRB/TRD UMIs per Cell", medianUMIsChain1,
  "Median TRA/TRG UMIs per Cell", medianUMIsChain2,
  "Cells with Productive TRB", cellsWithProductiveChainTRB,
  "Cells with Productive TRD", cellsWithProductiveChainTRD,
  "Cells with Productive TRA", cellsWithProductiveChainTRA,
  "Cells with Productive TRG", cellsWithProductiveChainTRG,
  "Cells with Productive TRATRB pair", cellsWithProductiveChainTRATRB,
  "Cells with Productive TRGTRD pair", cellsWithProductiveChainTRGTRD
) %>%
  mutate(value = as.numeric(value)) %>%
  mutate(value = label_comma()(round(value)))

vdj_t_annotation <- vdj_t_tbl

names(vdj_t_tbl) <- c("", "")
vdj_t_tbl %>% 
    kbl() %>% 
    kable_paper("hover", html_font = html_font)
```

Row
----------

### GEX Association `r infoIcon("gexAssociation")`

```{r eval = (include_tcr & include_gex)}
## Only plot cluster when there are more than 150 filtered cells
if(filtered_cells >= 150){
    ##clusterPlot <- DimPlot(object=seuratData, reduction="umap", label=TRUE, repel=TRUE)
    ## extract data from seuratData
    tcr_cdrSeq <- read_tsv(params$VDJ_T_report) %>%
        select(`#barcode`, `chain1`, `chain2`)
    tcr_cdrSeq$chain1_cdr3 <- ""
    tcr_cdrSeq$chain2_cdr3 <- ""
    for(i in 1:nrow(tcr_cdrSeq)){
        tcr_cdrSeq$chain1_cdr3[i] <- unlist(strsplit(tcr_cdrSeq$chain1[i], ","))[6]
        tcr_cdrSeq$chain2_cdr3[i] <- unlist(strsplit(tcr_cdrSeq$chain2[i], ","))[6]
    }
    
    tcr_cells <- vdj_t_knee %>%
        filter(group == "cell") %>%
        pull(CB)
    tcr_data <- vdj_t_kneeData %>%
        filter(CB %in% tcr_cells) %>%
        left_join(tcr_cdrSeq, by = c("CB" = "#barcode"))
    clusterData2 <- clusterData %>% left_join(tcr_data, by = c("bc" = "CB")) %>%
        dplyr::select(bc, UMAP_1, UMAP_2, chain1_cdr3, chain2_cdr3) %>%
        dplyr::mutate(
            text = paste0(chain1_cdr3, "+", chain2_cdr3),
            type = case_when(
                !is.na(chain1_cdr3) & !is.na(chain2_cdr3) ~ "Detected",
                TRUE ~ "Not captured"
            )
        )

    plot_ly(clusterData2, x = ~UMAP_1, y= ~UMAP_2, color = ~type, 
            text = ~text,
            type = 'scatter', mode = 'markers',
            marker = list(opacity = 0.5),
            colors = c("#9370DB", "grey"),
            hovertemplate = 'CDR3: %{text}<extra><b>Type: %{fullData.name}</b></extra>') %>%
        config_plotly_fig() %>%
        toWebGL()
    
    ##clusterPlot %>% ggplotly() %>%
    ##    config(displaylogo = FALSE,
    ##           modeBarButtonsToRemove = c('zoom', 'pan', 'select', 'zoomIn', 'zoomOut', 'autoScale',
    ##                                      'hoverClosestCartesian', 'hoverCompareCartesian')) %>% toWebGL()
}else{
    cat("Too few cells: ", filtered_cells, "(filtered by nFeature >= 200)\n")
}
```

```{r eval = !(include_tcr & include_gex)}
cat("No gene expression library\n")
```

### Top 10 Clonotypes `r infoIcon("Clonetypes_top10")`

```{r eval = include_tcr}
fig <- plot_ly(data = vdj_t_cloneType %>% filter(id<=10), x = ~id, y = ~cellCount, type = "bar")
fig <- layout(fig, showlegend = FALSE)
config_plotly_fig(fig)
```

Row {style="margin-right: 8px"}
----------

### Identified Clonetypes (top 1000) `r infoIcon("Clonetypes_top1000")` {style="width: 100% !important"} 

```{r eval = include_tcr}
vdj_t_cloneType %>%
    filter(id <= 1000) %>%
    DT::datatable(rownames = FALSE, width = "100%",
                  options = list(scrollX = T, scrollY = F, pageLength = 10))
```

Row {data-height=400}
----------

### V Region Coverage (Chain1) `r infoIcon("Chain_coverage")`

```{r eval = include_tcr, fig.width = 7, fig.height = 4}
coverage_plots <- plot_VDJ_coverage(
    cells = vdj_t_cells$CB, 
    barcode_report = params$VDJ_T_report, 
    airr_report = params$VDJ_T_airr, 
    trust4_final_out = params$VDJ_T_finalOut, 
    type = "VDJ-T"
)
coverage_plots$chain1_plot
```

### V Region Coverage (Chain2) `r infoIcon("Chain_coverage")`


```{r eval = include_tcr, fig.width = 7, fig.height = 4}
coverage_plots$chain2_plot
```

Row {data-height=400}
----------

### Lineage & CloneType Stats `r infoIcon("Lineage_annotation")`

```{r eval = include_tcr}
tcr_lineageInfo <- getLineage(cells = vdj_t_cells$CB,
                              barcode_report = params$VDJ_T_report,
                              airr_report = params$VDJ_T_airr)
                              
write_tsv(tcr_lineageInfo, file = paste0(params$sampleName, "_TCR_results.productiveOnly_withLineage.tsv"))

tcr_pairing_clones <- tcr_lineageInfo %>%
    select(chain1_V, chain1_D, chain1_J, chain1_cdr3,
           chain2_V, chain2_J, chain2_cdr3) %>%
    na.omit() %>%
    distinct() %>%
    nrow()
tcr_lineage_number <- tcr_lineageInfo %>%
    pull(lineageName) %>%
    unique() %>% length()
multipleLineageCellNumber <- tcr_lineageInfo %>%
    filter(lineageType == "multiple") %>%
    nrow()
multipleCellLineageNumber <- tcr_lineageInfo %>%
    filter(lineageType == "multiple") %>%
    pull(lineageName) %>%
    unique() %>% length()
singleCellLineageNumber <- tcr_lineageInfo %>%
    filter(lineageType == "single") %>%
    pull(lineageName) %>%
    unique() %>% length()

pairingAccuracy <- calc_pairing_accuracy(tcr_lineageInfo)
entropy <- getEntropy(tcr_lineageInfo)
clonality <- getClonality(entropy, tcr_pairing_clones)


lineage_tbl <- tribble(
    ~term, ~value,
    "Clones (Paired)", label_comma()(tcr_pairing_clones),
    "Lineage Number", label_comma()(tcr_lineage_number),
    "Single Cell Lineage Number", label_comma()(singleCellLineageNumber),
    "Multiple Cell Lineage Number", label_comma()(multipleCellLineageNumber),
    "Cells in Multiple Cell Lineages", label_comma()(multipleLineageCellNumber),
    "Total Cells with Paired Clones", label_comma()(nrow(tcr_lineageInfo)),
    "Pairing Accuracy", label_percent(0.01)(pairingAccuracy),
    "Shannon Entropy", label_number(0.001)(entropy),
    "Clonality", label_number(0.001)(clonality)
)

vdj_t_metrics_final <- bind_rows(
    vdj_t_stats,
    vdj_t_sequencing_stats,
    vdj_t_annotation,
    lineage_tbl
)

write_tsv(vdj_t_metrics_final,
          paste0(params$sampleName, "_VDJ-T.metrics.tsv"), 
          col_names=FALSE)

vdj_t_metrics_final %>%
    split(vdj_t_metrics_final$term) %>% 
    lapply(FUN=function(x) { x$value }) %>% 
    write_json(paste0(params$sampleName, "_VDJ-T.metrics.json"), pretty = TRUE, auto_unbox = TRUE)

names(lineage_tbl) <- c("", "")
lineage_tbl %>% 
    kbl() %>% 
    kable_paper("hover", html_font = html_font)
```

### Lineage Plots `r infoIcon("Lineage_plot")`

```{r eval = include_tcr, fig.width = 7, fig.height=3.5}
pie_d <- tcr_lineageInfo %>% ungroup %>% 
    group_by(lineageType) %>%
    summarize(count = n()) %>%
    dplyr::mutate(
        labels = case_when(
            lineageType == "single" ~ "Cell in Singleton Lineages",
            lineageType == "multiple" ~ "Cell in Expanded Lineages"
        )
    )
total <- sum(pie_d$count)
pie_d <- pie_d %>%
    mutate(
        percentage = count/total,
        percentage = label_percent(0.01)(percentage)
    )

LineageCellNumber <- tcr_lineageInfo %>% 
    filter(lineageType == "multiple") %>%
    group_by(lineageName) %>%
    summarize(count = n()) %>%
    arrange(desc(count))

if(nrow(LineageCellNumber)>50){
    LineageCellNumber <- LineageCellNumber[1:50, ]
}

if(nrow(LineageCellNumber)>0){
    barplot_d <- tibble(rank=1:nrow(LineageCellNumber),
                        cellNum = LineageCellNumber$count)
}else{
    barplot_d <- tibble(rank=numeric(),
                        cellNum = numeric())
}

p1 <- ggplot(pie_d, aes(x = "", y = count, fill = labels))+geom_col(color = "black") +
    geom_text(aes(label = percentage),
                  position = position_stack(vjust = 0.5),
                  color = "white") +
    coord_polar(theta = "y")+
    scale_fill_manual(values = c("Cell in Expanded Lineages" = "#4169E1", "Cell in Singleton Lineages" = "grey"))+
    theme_void()+
    theme(legend.title = element_blank(), legend.position = "top", legend.direction = "vertical")

p2 <- ggplot(barplot_d, aes(x=rank, y = cellNum))+geom_bar(stat = "identity", fill = "#4169E1", color = "black")+
    xlab("Multi-cell Lineages") + ylab("Cell Count") +
    theme_classic()
p1+p2
```


`r if(!include_tcr) {"\\end{comment}"} else {NULL}`

`r if(!include_bcr) {"\\begin{comment}"} else {NULL}`

VDJ-B {data-orientation=rows}
====================

<h2 style="margin-top: 0.5rem; font-weight: bold;">Sample: `r params$sampleName` (VDJ-B)</h2>


```{r include=FALSE, eval = include_bcr}
vdj_b_cells <- read_tsv(params$VDJ_B_cells)
vdj_b_combinedInfo <- combineInfo(cells = vdj_b_cells$CB, 
                                  barcode_report = params$VDJ_B_report,
                                  airr_report = params$VDJ_B_airr)

vdj_b_cloneType <- vdj_b_combinedInfo %>%
    dplyr::select(chain1_cdr3aa, chain2_cdr3aa,
                  chain1_cdr3, chain2_cdr3,
                  chain1_V, chain1_D, chain1_J, 
                  chain2_V, chain2_J) %>%
    group_by(chain1_cdr3aa, chain2_cdr3aa, chain1_cdr3, chain2_cdr3, chain1_V, chain1_D, chain1_J, chain2_V, chain2_J) %>%
    summarize(cellCount = n()) %>%
    ungroup() %>%
    mutate(
        label1 = case_when(
            !is.na(chain1_V) ~ str_sub(chain1_V, 1L, 3L),
            !is.na(chain1_D) ~ str_sub(chain1_D, 1L, 3L),
            !is.na(chain1_J) ~ str_sub(chain1_J, 1L, 3L),
            TRUE ~ "Heavy"
        ),
        label2 = case_when(
            !is.na(chain2_V) ~ str_sub(chain2_V, 1L, 3L),
            !is.na(chain2_J) ~ str_sub(chain2_J, 1L, 3L),
            TRUE ~ "Light"
        ),
        Hchain_VDJ = paste0(chain1_V, "|", chain1_D, "|", chain1_J),
        Lchain_VDJ = paste0(chain2_V, "|", chain2_J)
    ) %>%
    mutate(
        cloneType = case_when(
            !is.na(chain1_cdr3aa) & !is.na(chain2_cdr3aa) ~ paste0(label1, ":", chain1_cdr3aa, ";", label2, ":", chain2_cdr3aa),
            is.na(chain1_cdr3aa) ~ paste0(label2, ":", chain2_cdr3aa),
            is.na(chain2_cdr3aa) ~ paste0(label1, ":", chain1_cdr3aa)
        )
    ) %>%
    arrange(desc(cellCount)) %>%
    mutate(Frequency = cellCount/nrow(vdj_b_combinedInfo)) %>%
    dplyr::select(cloneType, Hchain_VDJ, Lchain_VDJ, cellCount, Frequency)

vdj_b_cloneType$Hchain_VDJ[which(vdj_b_cloneType$Hchain_VDJ == "NA|NA|NA")] <- NA
vdj_b_cloneType$Lchain_VDJ[which(vdj_b_cloneType$Lchain_VDJ == "NA|NA")] <- NA
    
vdj_b_cloneType <- vdj_b_cloneType %>%
    mutate(
        id = 1:nrow(vdj_b_cloneType),
        Frequency = scales::label_percent(0.01)(Frequency)
    )
write_tsv(vdj_b_combinedInfo, file = paste0(params$sampleName, "_BCR_results.tsv"))
write_tsv(vdj_b_cloneType, file = paste0(params$sampleName, "_BCR_clonotypes.tsv"))
```

Row
----------

### Estimated Number of Cells


```{r include = FALSE, eval = include_bcr}
vdj_b_metrics <- fromJSON(params$VDJ_B_metrics)

```

```{r eval = include_bcr}
valueBox(vdj_b_metrics$cells %>% as.numeric() %>% label_comma()(), icon = "fa-circle-notch", color = "info")
```

### Mean VDJ Reads per Cell

```{r eval = include_bcr}
valueBox(vdj_b_metrics$meanVDJReadsPerCell %>% as.numeric() %>% round %>% label_comma()(), icon = "fa-chart-bar", color = "primary")
```

### Total Clonotypes Discovered

```{r eval = include_bcr}
valueBox(nrow(vdj_b_cloneType) %>% label_comma()(), icon = "fa-barcode", color = "warning")
```

Row
----------

### VDJ Stats `r infoIcon("VDJ_stats")`

```{r eval = include_bcr}
##Estimated Number of Cells
##Reads in Cells Mapped to Gene
##Fraction of Reads in Cells
##Mean Reads per Cell
##Median Reads per Cell
##UMIs in Cells
##Mean UMI per Cell
##Median UMI per Cell
##Mean Gene per Cell
##Median Gene per Cell

fractionAssembled <- as.numeric(vdj_b_metrics$totalReadsInCell)/(as.numeric(vdj_b_metrics$totalRawReads)*as.numeric(vdj_b_metrics$validBCreads))
fractionAssembled <- as.character(fractionAssembled)

vdj_b_tbl <- tribble(
  ~term, ~value,
  "Estimated Number of Cells (including non-pairing cells)", vdj_b_metrics$cells,
  "Reads in Cells Mapped to VDJ Gene", vdj_b_metrics$totalReadsInCell,
  "Fraction of Reads Used in Assembly", fractionAssembled,
  "Mean VDJ Reads per Cell", vdj_b_metrics$meanVDJReadsPerCell,
  "Median VDJ Reads per Cell", vdj_b_metrics$medianVDJReadsPerCell,
  "Mean Total UMIs per Cell", vdj_b_metrics$meanTotalUMIsPerCell,
  "Median Total UMIs per Cell", vdj_b_metrics$medianTotalUMIsPerCell,
  "Pairing Rate", vdj_b_metrics$pairingRate,
  "Total Clonotypes Detected", vdj_b_metrics$totalCloneTypes
) %>%
  mutate(value = as.numeric(value)) %>%
  mutate(value=case_when(value <= 1 ~ label_percent(0.01)(value),
                         value > 1 ~ label_comma()(round(value))))
## Rename UMI terms
if(!params$withUMI){
    vdj_b_tbl$term[which(vdj_b_tbl$term=="Mean Total UMIs per Cell")] <- "Mean Total Reads per Cell"
    vdj_b_tbl$term[which(vdj_b_tbl$term=="Median Total UMIs per Cell")] <- "Median Total Reads per Cell"
}

vdj_b_stats <- vdj_b_tbl

names(vdj_b_tbl) <- c("", "")
vdj_b_tbl %>% 
    kbl() %>% 
    kable_paper("hover", html_font = html_font)
```

### Knee Plot `r infoIcon("VDJ_kneePlot")`

```{r eval = include_bcr}
cellNum <- as.numeric(vdj_b_metrics$cells)
vdj_b_kneeData <- read_tsv(params$VDJ_B_kneeOut, col_names = c("CB", "UMI"))
vdj_b_knee <- vdj_b_kneeData %>% 
    mutate(
        cell = c(1:nrow(vdj_b_kneeData)),
        group = case_when(
            CB %in% vdj_b_cells$CB ~ "cell",
            TRUE ~ "background"
        )
    )
fig <- plot_ly(data = vdj_b_knee, x = ~cell, y = ~UMI, type = 'scatter', mode = 'lines',
               color = ~group, colors = c('grey', '#002366'),
               hovertemplate = 'UMI: %{y}<extra>%{fullData.name}</extra>',
               line = list(width = 3),
               height = 400, width = 360)

fig <- layout(fig, xaxis = list(title = "Barcode Rank", type = "log"),yaxis = list(type = "log"), showlegend = FALSE)

if(!params$withUMI){
    fig <- layout(fig, yaxis = list(title = "Reads"))

}
config_plotly_fig(fig) %>% toWebGL()
```

Row {data-height=350}
----------

### Sequencing Stats `r infoIcon("Sequencing_stats")`

```{r eval = include_bcr}
##Number of Reads
##Reads With Valid Barcodes
##Sequencing Saturation
##Q30 Bases in CB+UMI
##Q30 Bases in RNA read
##Total VDJ Gene Fragments Detected

vdj_b_tbl <- tribble(
  ~term, ~value,
  "Number of Reads", vdj_b_metrics$totalRawReads,
  "Reads With Valid Barcodes", vdj_b_metrics$validBCreads,
  "Sequencing Saturation", vdj_b_metrics$saturation,
  "Q30 Bases in CB+UMI", vdj_b_metrics$q30InCBandUMI,
  "Q30 Bases in RNA read", vdj_b_metrics$q30InRNA
) %>%
  mutate(value = as.numeric(value)) %>%
  mutate(value=case_when(value <= 1 ~ label_percent(0.01)(value),
                         value > 1 ~ label_comma()(round(value))))

vdj_b_sequencing_stats <- vdj_b_tbl

names(vdj_b_tbl) <- c("", "")
vdj_b_tbl %>% 
    kbl() %>% 
    kable_paper("hover", html_font = "arial, helvetica, sans-serif")
```

### V(D)J Annotation `r infoIcon("BCR_annotation")`

```{r eval = include_bcr}
##Cells with productive V-J spanning pair
##Cells with productive V-J spanning (IGK, IGH) pair
##Cells with productive V-J spanning (IGL, IGH) pair
##Cells with productive IGH contig
##Cells with productive IGK contig
##Cells with productive IGL contig
##Paired clonotype diversity
medianUMIsChain1 <- vdj_b_combinedInfo$chain1_expr %>% median(na.rm = TRUE) %>% as.numeric()
medianUMIsChain2 <- vdj_b_combinedInfo$chain2_expr %>% median(na.rm = TRUE) %>% as.numeric()
cellsWithProductiveChainIGH <- vdj_b_combinedInfo %>%
    filter(chain1_productive, chain1_type == "IGH") %>% nrow() %>% as.numeric()
cellsWithProductiveChainIGK <- vdj_b_combinedInfo %>%
    filter(chain2_productive, chain2_type == "IGK") %>% nrow() %>% as.numeric()
cellsWithProductiveChainIGL <- vdj_b_combinedInfo %>%
    filter(chain2_productive, chain2_type == "IGL") %>% nrow() %>% as.numeric()
cellsWithProductiveChainIGKIGH <- vdj_b_combinedInfo %>%
    filter(chain1_productive,
           chain2_productive, 
           chain1_type == "IGH", 
           chain2_type == "IGK") %>% 
    nrow() %>% as.numeric()
cellsWithProductiveChainIGLIGH <- vdj_b_combinedInfo %>%
    filter(chain1_productive, 
           chain2_productive, 
           chain1_type == "IGH", 
           chain2_type == "IGL") %>% 
    nrow() %>% as.numeric()

vdj_b_tbl <- tribble(
  ~term, ~value,
  "Median IGH UMIs per Cell", medianUMIsChain1,
  "Median IGK/L UMIs per Cell", medianUMIsChain2,
  "Cells with Productive IGH", cellsWithProductiveChainIGH,
  "Cells with Productive IGK", cellsWithProductiveChainIGK,
  "Cells with Productive IGL", cellsWithProductiveChainIGL,
  "Cells with Productive IGKIGH pair", cellsWithProductiveChainIGKIGH,
  "Cells with Productive IGLIGH pair", cellsWithProductiveChainIGLIGH
) %>%
  mutate(value = as.numeric(value)) %>%
  mutate(value = label_comma()(round(value)))

vdj_b_annotation <- vdj_b_tbl

names(vdj_b_tbl) <- c("", "")
vdj_b_tbl %>% 
    kbl() %>% 
    kable_paper("hover", html_font = html_font)
```

Row
----------

### GEX Association `r infoIcon("gexAssociation")`

```{r eval = (include_bcr & include_gex)}
## Only plot cluster when there are more than 150 filtered cells
if(filtered_cells >= 150){
    ##clusterPlot <- DimPlot(object=seuratData, reduction="umap", label=TRUE, repel=TRUE)
    bcr_cdrSeq <- read_tsv(params$VDJ_B_report) %>%
        select(`#barcode`, `chain1`, `chain2`)
    bcr_cdrSeq$chain1_cdr3 <- ""
    bcr_cdrSeq$chain2_cdr3 <- ""
    for(i in 1:nrow(bcr_cdrSeq)){
        bcr_cdrSeq$chain1_cdr3[i] <- unlist(strsplit(bcr_cdrSeq$chain1[i], ","))[6]
        bcr_cdrSeq$chain2_cdr3[i] <- unlist(strsplit(bcr_cdrSeq$chain2[i], ","))[6]
    }
    ## extract data from seuratData
    bcr_cells <- vdj_b_knee %>%
        filter(group == "cell") %>%
        pull(CB)
    bcr_data <- vdj_b_kneeData %>%
        filter(CB %in% bcr_cells) %>%
        left_join(bcr_cdrSeq, by = c("CB" = "#barcode"))
    clusterData2 <- clusterData %>% left_join(bcr_data, by = c("bc" = "CB")) %>%
        dplyr::select(bc, UMAP_1, UMAP_2, chain1_cdr3, chain2_cdr3) %>%
        dplyr::mutate(
            text = paste0(chain1_cdr3, "+", chain2_cdr3),
            type = case_when(
                !is.na(chain1_cdr3) & !is.na(chain2_cdr3) ~ "Detected",
                TRUE ~ "Not captured"
            )
        )

    plot_ly(clusterData2, x = ~UMAP_1, y= ~UMAP_2, color = ~type, 
            text = ~text,
            type = 'scatter', mode = 'markers',
            marker = list(opacity = 0.5),
            colors = c("#9370DB", "grey"),
            hovertemplate = 'CDR3: %{text}<extra><b>Type: %{fullData.name}</b></extra>') %>%
        config_plotly_fig() %>%
        toWebGL()
    
    ##clusterPlot %>% ggplotly() %>%
    ##    config(displaylogo = FALSE,
    ##           modeBarButtonsToRemove = c('zoom', 'pan', 'select', 'zoomIn', 'zoomOut', 'autoScale',
    ##                                      'hoverClosestCartesian', 'hoverCompareCartesian')) %>% toWebGL()
}else{
    cat("Too few cells: ", filtered_cells, "(filtered by nFeature >= 200)\n")
}
```

```{r eval = !(include_bcr & include_gex)}
cat("No gene expression library\n")
```

### Top 10 Clonotypes `r infoIcon("Clonetypes_top10")`

```{r eval = include_bcr}
fig <- plot_ly(data = vdj_b_cloneType %>% filter(id<=10), x = ~id, y = ~cellCount, type = "bar")
fig <- layout(fig, showlegend = FALSE)
config_plotly_fig(fig)
```

Row {style="margin-right: 8px"}
----------

### Identified Clonotypes (top 1000) `r infoIcon("Clonetypes_top1000")` {style="width: 100% !important"}

```{r eval = include_bcr}
vdj_b_cloneType %>%
    filter(id <= 1000) %>%
    DT::datatable(rownames = FALSE, width = "100%",
                  options = list(scrollX = T, scrollY = F, pageLength = 10))
```

Row {data-height=400}
----------

### V Region Coverage (Chain1) `r infoIcon("Chain_coverage")`

```{r eval = include_bcr, fig.width = 7, fig.height = 4}
coverage_plots <- plot_VDJ_coverage(
    cells = vdj_b_cells$CB, 
    barcode_report = params$VDJ_B_report, 
    airr_report = params$VDJ_B_airr, 
    trust4_final_out = params$VDJ_B_finalOut, 
    type = "VDJ-B"
)
coverage_plots$chain1_plot
```

### V Region Coverage (Chain2) `r infoIcon("Chain_coverage")`


```{r eval = include_bcr, fig.width = 7, fig.height = 4}
coverage_plots$chain2_plot
```

Row {data-height=400}
----------

### Lineage & Clonotype Stats `r infoIcon("Lineage_annotation")`

```{r eval = include_bcr}
bcr_lineageInfo <- getLineage(cells = vdj_b_cells$CB,
                              barcode_report = params$VDJ_B_report,
                              airr_report = params$VDJ_B_airr)

write_tsv(bcr_lineageInfo, file = paste0(params$sampleName, "_BCR_results.productiveOnly_withLineage.tsv"))

bcr_pairing_clones <- bcr_lineageInfo %>%
    select(chain1_V, chain1_D, chain1_J, chain1_cdr3,
           chain2_V, chain2_J, chain2_cdr3) %>%
    na.omit() %>%
    distinct() %>%
    nrow()
bcr_lineage_number <- bcr_lineageInfo %>%
    pull(lineageName) %>%
    unique() %>% length()
multipleLineageCellNumber <- bcr_lineageInfo %>%
    filter(lineageType == "multiple") %>%
    nrow()
multipleCellLineageNumber <- bcr_lineageInfo %>%
    filter(lineageType == "multiple") %>%
    pull(lineageName) %>%
    unique() %>% length()
singleCellLineageNumber <- bcr_lineageInfo %>%
    filter(lineageType == "single") %>%
    pull(lineageName) %>%
    unique() %>% length()

pairingAccuracy <- calc_pairing_accuracy(bcr_lineageInfo)
entropy <- getEntropy(bcr_lineageInfo)
clonality <- getClonality(entropy, bcr_pairing_clones)


lineage_tbl <- tribble(
    ~term, ~value,
    "Clones (Paired)", label_comma()(bcr_pairing_clones),
    "Lineage Number", label_comma()(bcr_lineage_number),
    "Single Cell Lineage Number", label_comma()(singleCellLineageNumber),
    "Multiple Cell Lineage Number", label_comma()(multipleCellLineageNumber),
    "Cells in Multiple Cell Lineages", label_comma()(multipleLineageCellNumber),
    "Total Cells with Paired Clones", label_comma()(nrow(bcr_lineageInfo)),
    "Pairing Accuracy", label_percent(0.01)(pairingAccuracy),
    "Shannon Entropy", label_number(0.001)(entropy),
    "Clonality", label_number(0.001)(clonality)
)

vdj_b_metrics_final <- bind_rows(
    vdj_b_stats,
    vdj_b_sequencing_stats,
    vdj_b_annotation,
    lineage_tbl
)

write_tsv(vdj_b_metrics_final,
          paste0(params$sampleName, "_VDJ-B.metrics.tsv"), 
          col_names=FALSE)

vdj_b_metrics_final %>%
    split(vdj_b_metrics_final$term) %>% 
    lapply(FUN=function(x) { x$value }) %>% 
    write_json(paste0(params$sampleName, "_VDJ-B.metrics.json"), pretty = TRUE, auto_unbox = TRUE)

names(lineage_tbl) <- c("", "")
lineage_tbl %>% 
    kbl() %>% 
    kable_paper("hover", html_font = html_font)
```

### Lineage Plots `r infoIcon("Lineage_plot")`


```{r eval = include_bcr, fig.width = 7, fig.height=3.5}
pie_d <- bcr_lineageInfo %>% ungroup %>% 
    group_by(lineageType) %>%
    summarize(count = n()) %>%
    dplyr::mutate(
        labels = case_when(
            lineageType == "single" ~ "Cell in Singleton Lineages",
            lineageType == "multiple" ~ "Cell in Expanded Lineages"
        )
    )
total <- sum(pie_d$count)
pie_d <- pie_d %>%
    mutate(
        percentage = count/total,
        percentage = label_percent(0.01)(percentage)
    )

LineageCellNumber <- bcr_lineageInfo %>% 
    filter(lineageType == "multiple") %>%
    group_by(lineageName) %>%
    summarize(count = n()) %>%
    arrange(desc(count))

if(nrow(LineageCellNumber)>50){
    LineageCellNumber <- LineageCellNumber[1:50, ]
}

if(nrow(LineageCellNumber)>0){
    barplot_d <- tibble(rank=1:nrow(LineageCellNumber),
                        cellNum = LineageCellNumber$count)
}else{
    barplot_d <- tibble(rank=numeric(),
                        cellNum = numeric())
}

p1 <- ggplot(pie_d, aes(x = "", y = count, fill = labels))+geom_col(color = "black") +
    geom_text(aes(label = percentage),
                  position = position_stack(vjust = 0.5),
                  color = "white") +
    coord_polar(theta = "y")+
    scale_fill_manual(values = c("Cell in Expanded Lineages" = "#4169E1", "Cell in Singleton Lineages" = "grey"))+
    theme_void()+
    theme(legend.title = element_blank(), legend.position = "top", legend.direction = "vertical")

p2 <- ggplot(barplot_d, aes(x=rank, y = cellNum))+geom_bar(stat = "identity", fill = "#4169E1", color = "black")+
    xlab("Multi-cell Lineages") + ylab("Cell Count") +
    theme_classic()
p1+p2
```


`r if(!include_bcr) {"\\end{comment}"} else {NULL}`

Running Info {data-orientation=rows}
====================

Row {data-height=600}
----------

### Running Information `r infoIcon("runningInfo")`

```{r}
version_info <- fromJSON(params$version_json)

if(include_gex){
    cellCallingMethod <- version_info$soloCellFilter
}else{
    cellCallingMethod <- "cellRanger 2.2"
}
version_tbl <- tribble(
  ~term, ~value,
  "Sample ID", params$sampleName,
  "Pipeline Version", version_info$pipeline_version,
  "Reference Dir", version_info$referenceDir,
  "Reference GTF", version_info$referenceGTF,
  "Whitelist", version_info$whitelist,
  "VDJ Assembled with Only cDNA Reads", version_info$assembleWithcDNAreadOnly,
  "STAR Version", version_info$STAR_version,
  "Whitelist Matching", version_info$soloCBmatchWLtype,
  "UMIfiltering", version_info$soloUMIfiltering,
  "UMIdedup", version_info$soloUMIdedup,
  "Cell Calling", cellCallingMethod,
  "includeIntron", version_info$includeIntron,
  "includeMultiReads", version_info$includeMultiReads
)
if(!params$withUMI){
    version_tbl <- version_tbl %>%
        filter(!(term %in%c("UMIfiltering", "UMIdedup")))
}
if(!include_gex){
    version_tbl <- version_tbl %>%
        filter(!(term %in%c("includeIntron", "includeMultiReads")))
}
names(version_tbl) <- c("", "")
version_tbl %>% 
    kbl() %>% 
    kable_paper("hover", html_font = html_font)
```

```{js}
// set knee plot margin to auto
$( document ).ready(function() {
    document.querySelectorAll("div.plot-container > div.svg-container").forEach(el => el.style.margin = "auto");
});
```
